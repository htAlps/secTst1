Γ0․s0_scratchpad.rs․          ᚖ․Catg․Tags: CODE, KB
․․ο․𐍂𐓙f𐓙εl․𐡇․𐒱lpíz𐓙r․         ᚖ․Subj․Tags: Code Fragments to Support Associated Module 
·   ·                           ·

Contents:

  № Nomenclature, Glossary, Staging § Footer․

Anouncements:


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․9․⛩κ✨λ Short Programs § Code Fragments  (Rev․ Chrono)

․4․ PREAMBLE:

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
❓𐤒 QaaS ─ Questions Answers Actions § Searches

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
🔭 URLs →

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
⭐ν NOTES:


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․κλ Short Programs (Rev․ Chrono)


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
․5․ 



•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·

                                                                 ·════ 🔻 ════·
                                                                       💥
                                                                 ·════ 🔻 ════·

·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․κλ Short Programs (Rev․ Chrono)


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
․5․λ 



•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
•           ·                   ·                   ·                   ·                   ·                   ·                   ·            • 
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·

                                                                 ·════ 🔻 ════·
                                                                       💥
                                                                 ·════ 🔻 ════·

·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․κλ Short Programs (Rev․ Chrono)


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
․5․ 



•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·

                                                                 ·════ 🔻 ════·
                                                                       💥
                                                                 ·════ 🔻 ════·

·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․κλ Short Programs (Rev․ Chrono)

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// ✨λ s0_scratch_pad  ι✧21․11․22✦10․08․26․ 🌎η ✧22․10․22․
#![allow(dead_code)]
extern crate regex;
use regex::Regex;
use std::error::Error;
use std::fs;
use std::fs::File;
use std::path::Path;
use std::io::Read;
use lazy_static::lazy_static;

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
//λ unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`
#[cfg(test)]
mod test_regex {
    use super::*;

    const TEST_STR: &str = r#"\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln03: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln04: aa,   ddd3,   bb,   ccc,   ddd44,   eee,"  f,  \n\
ln05: a",   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln06: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln07: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln08: aa,   ddd3,   bb,   ccc,   ddd44,   eee,"  f,  \n\
ln09: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln10: a",   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln11: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln12: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln13: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln14: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln15: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln16: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln17: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
Downloaded Data (x. Prefix)                          \n\
Controlled Text for Testing RegEx Captures
"#;

    #[test]
    fn test_preamble() {
        print!("TEST_STR: {TEST_STR} \n")
    }

}

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
//λ common functions
fn prt_chars(ss: &String) {
    print!("    ss.chars(): ");
    for val in ss.chars() {
        print!("{val} ");
    }
    print!("\n\n");
}


///λ Read a file the old way
fn read_file(file_path: &str) -> String {

    let path = Path::new(file_path);
    print!("path.display(): {}\n", path.display());

    let mut ff = match File::open(&path) {
        Err(ee) => panic!("Open Error: {ee}\n"),
        Ok(ff)  => ff,
    };


    let mut ss = String::new();
    match ff.read_to_string(&mut ss) {
        Err(ee) => panic!("read_file::Read Error: {ee}\n"),
        Ok(_) => ss
    }
}


///λ Capture across multiple lines
fn capture_across_mult_lines(ss: String) {

    //  •═══··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    print!("{}🎡𐡋 Checking: Capturing across multiple lines \n", C_LL);

    // first a simple patern
    let re = Regex::new(r#"(dd1)"#).unwrap();

    for cap in re.captures_iter(&ss) {
        print!("\nMatch:   {:?}\n", cap);
    }

    print!("\n🎡𐡋 Capture all text inside: (,' text ',)  \n");

    // ignoring all delimiters between single quotes in one line (,'  text  ',)
    let re = Regex::new(r#",'(.*)',"#).unwrap();

    for cap in re.captures_iter(&ss) {
        print!("\nMatch:   {:?}\n", cap);
    }

    print!("\n🎡𐡋 Capture all text inside: (,\" text \",)  \n");

    // ignoring all delimiters between double quotes in multiple lines (,"  text  ",)
    let re = Regex::new(r#"(?s),"(.*)","#).unwrap();

    for cap in re.captures_iter(&ss) {
        print!("\n\nMatch:   {:?}\n\n", cap);
    }
}


///λ this RegEx Helper looseley ratches an IPv4 addr
fn has_ipv4(ss: &str) -> bool {

    lazy_static! {
        static ref RE_IPV4: Regex = Regex::new(r" \d\d?\d?\.\d\d?\d?\.\d\d?\d?\.\d\d?\d? ").unwrap();
    }
    RE_IPV4.is_match(ss)
}


///λ This RegEx Helper removes (," ... ",) in a single line
fn remove_1_inline_quotes(ss: String) -> String {

    lazy_static! {
        static ref RE_REMOVE_1_INLINE_QUOTES: Regex = Regex::new(r#"(?P<yes1>.*)(?P<no>,".*",)(?P<yes2>.*)"#).unwrap();
    }
    let res = RE_REMOVE_1_INLINE_QUOTES.replace_all(&ss, "≺1:$yes1≻,--removed_inline_quotation--,≺2:$yes2≻");
    res.to_string()
}


///λ This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_2_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_2_MULTILINE_QUOTES: Regex = Regex::new(r#"((?ms:.)(?P<yes1>.*)(?P<no>,".*",)(?P<yes2>.*))"#).unwrap();
    }
    let res = RE_REMOVE_2_MULTILINE_QUOTES.replace_all(&ss, "≺1:$yes1≻,--removed_multiline_quotation--,≺2:$yes2≻");
    res.to_string()
}


///λ This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_3_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_3_MULTILINE_QUOTES: Regex = Regex::new(r#"((?P<yes1>(?ms:.).*)(?P<no>,".*",)(?P<yes2>.*))"#).unwrap();
    }
    let res = RE_REMOVE_3_MULTILINE_QUOTES.replace_all(&ss, "≺1:$yes1≻,--removed_multiline_quotation--,≺2:$yes2≻");
    res.to_string()
}


///⭐νλ This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_4_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_4_MULTILINE_QUOTES: Regex = Regex::new(r#"((?P<yes1>.*)(?P<no>(?ms:,".*?",))(?P<yes2>.*))"#).unwrap();
    }
    let res = RE_REMOVE_4_MULTILINE_QUOTES.replace_all(&ss, "≺1:$yes1≻,--removed_quoted_field--,≺2:$yes2≻");
    res.to_string()
}


///λ This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_5_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_5_MULTILINE_QUOTES: Regex = Regex::new(r#"((?P<yes1>.*)(?P<no>,".*",)(?P<yes2>(?ms:.).*))"#).unwrap();
    }
    let res = RE_REMOVE_5_MULTILINE_QUOTES.replace_all(&ss, "≺1:$yes1≻,--removed_multiline_quotation--,≺2:$yes2≻");
    res.to_string()
}


///λ This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_7_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_7_MULTILINE_QUOTES: Regex = Regex::new(r#"((?m)(?s:.)(?P<yes1>(?m).*)(?P<no>(?m),".*",)(?P<yes2>(?m).*))"#).unwrap();
    }
    let res = RE_REMOVE_7_MULTILINE_QUOTES.replace_all(&ss, "≺1:$yes1≻,--removed_multiline_quotation--,≺2:$yes2≻");
    res.to_string()
}


///λ This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n only in <no>
fn remove_8_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_8_MULTILINE_QUOTES: Regex = Regex::new(r#"((?m)(?P<yes1>(?m).*)(?s:.)(?P<no>(?m),".*",)(?P<yes2>(?m).*))"#).unwrap();
    }
    let res = RE_REMOVE_8_MULTILINE_QUOTES.replace_all(&ss, "≺1:$yes1≻,--removed_multiline_quotation--,≺2:$yes2≻");
    res.to_string()
}


///λ check_regex_helpers checks functionality in the in the development vector
pub fn check_regex_helpers() {
    // print!("{}🎡𐡋 checking regex helpers  \n\n", C_LL);

    let loaded_string1 = fs::read_to_string("/usr/local/sys/rust/data/x1_data.csv").expect("check::Read Error");
    let parsed_string = remove_1_inline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q11_p_data.csv", &parsed_string).expect("check::Write Parse1 Error");

    let parsed_string = remove_2_multiline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q12_p_data.csv", &parsed_string).expect("check::Write Parse2 Error");

    let parsed_string = remove_3_multiline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q13_p_data.csv", &parsed_string).expect("check::Write Parse3 Error");

    let parsed_string = remove_4_multiline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q14_p_data.csv", &parsed_string).expect("check::Write Parse4 Error");

    let parsed_string = remove_5_multiline_quotes(loaded_string1);
    fs::write("/usr/local/sys/rust/data/q15_p_data.csv", &parsed_string).expect("check::Write Parse5 Error");

    let re = Regex::new(r"(?m)^line \d+").unwrap();
    let m = re.find("line one\nline 2\n").unwrap();
    assert_eq!(m.as_str(), "line 2");

    let re = Regex::new(r"(?m)^line \d+").unwrap();
    let m = re.find("line one\nline 2\n").unwrap();
    assert_eq!(m.as_str(), "line 2");
}



// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// Constants Types § Enums

const C_LL: &str = "\n•═══════════··══════════════════·═══════════════════··═══════════•\n";

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
///λ check is the integration test executive function for this module
pub fn check() -> Result<(), String> {
    // print!("{}🎡𐡋 Checking: s1_exec  \n\n", C_LL);

    check_regex_helpers();

    Ok(())
    // panic!("for: No Reason");
}



•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of Regular Code 
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·


·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․κλ The Code Pit 

/// The Code Pit
/ *

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    print!("🎡𐡋 {my_location} \n");
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
///λ OLD VERSION c2_string_methods::check is the module suppervisor (an integration tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), Box<dyn Error>> {
    let my_location = "c2_string_methods::check";
    print!("🎡𐡋 {my_location} \n");

    str_basics();
    unicode_basics();
    string_methods_basic();
    string_methods_interm();

    Ok(())
    // don't panic!("for: No Reason");
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
///λ DEPRECATED - Implements Display for Lex so we can print a lex the way we want
impl fmt::Display for Lex{
    fn fmt(&self, ff: &mut fmt::Formatter) -> fmt::Result {
        let l = Lex::new();
        let mut res = String::new();
        res = res + &l.lb1.v();
        res = res + &l.ls1.v() + &self.cm.t().name()  + &l.sp.v() + &self.cm.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.dot.t().name() + &l.sp.v() + &self.dot.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.col.t().name() + &l.sp.v() + &self.col.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.els.t().name() + &l.sp.v() + &self.els.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.end.t().name() + &l.sp.v() + &self.end.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.eof.t().name() + &l.sp.v() + &self.eof.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.er.t().name()  + &l.sp.v() + &self.er.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.fld.t().name() + &l.sp.v() + &self.fld.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.id.t().name()  + &l.sp.v() + &self.id.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.iff.t().name() + &l.sp.v() + &self.iff.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.lb1.t().name() + &l.sp.v() + &self.lb1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.lb2.t().name() + &l.sp.v() + &self.lb2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.ls1.t().name() + &l.sp.v() + &self.ls1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.ls2.t().name() + &l.sp.v() + &self.ls2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.nl.t().name()  + &l.sp.v() + &self.nl.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.num.t().name() + &l.sp.v() + &self.num.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.pip.t().name() + &l.sp.v() + &self.pip.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.qt1.t().name() + &l.sp.v() + &self.qt1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.qt2.t().name() + &l.sp.v() + &self.qt2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.qt3.t().name() + &l.sp.v() + &self.qt3.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rb1.t().name() + &l.sp.v() + &self.rb1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rb2.t().name() + &l.sp.v() + &self.rb2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rng.t().name() + &l.sp.v() + &self.rng.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rs1.t().name() + &l.sp.v() + &self.rs1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rs2.t().name() + &l.sp.v() + &self.rs2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.sp.t().name()  + &l.sp.v() + &self.sp.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.stg.t().name() + &l.sp.v() + &self.stg.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.stl.t().name() + &l.sp.v() + &self.stl.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.txt.t().name() + &l.sp.v() + &self.txt.v() + &l.rs1.v();
        res = res + &l.rb1.v();
        write!(ff, "{res}")
    }
}



•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
⭐νλ OLD a83_regex_basics::mod_main NOTE THE BOX<DYN ERROR> 
pub fn mod_main() -> Result<(), Box<dyn Error>> {
    print!("{}🎡𐡋 Checking: a83_regex_basics \n\n", C_LL);

    // regex_basics();
    // regex_helpers();
    // regex_iterations();

    capture_across_mult_lines();


    Ok(())
    // don't panic!("for: No Reason");
}

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
//λ OLD c2_string_methods::mod_main
pub fn mod_main() -> Result<(), Box<dyn Error>> {
    print!("{}🎡𐡋 Checking: a83_regex_basics \n\n", C_LL);

    // regex_basics();
    // regex_helpers();
    // regex_iterations();

    capture_across_mult_lines();


    Ok(())
    // don't panic!("for: No Reason");
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
const C_LL: &str = "\n•═══════════··══════════════════·═══════════════════··═══════════•\n";
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
FROM LEXER
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
enum Lexium {
    Cm,
    Dot,
    Els,
    End,
    Eof,
    Er,
    Fld,
    Id,
    Iff,
    Lb,
    Lbb,
    Ls,
    Lss,
    Nl,
    Num,
    Pip,
    Rb,
    Rbb,
    Rng,
    Rs,
    Rss,
    Sp,
    Stg,
    st,
    Txt,
}

impl Lexium {
    fn new(&self) -> String {
        match self {
            Self::Cm    => ",".to_string(),
            Self::Dot   => ".".to_string(),
            Self::Els   => "".to_string(),
            Self::End   => "".to_string(),
            Self::Eof   => "".to_string(),
            Self::Er    => "".to_string(),
            Self::Fld   => "".to_string(),
            Self::Id    => "".to_string(),
            Self::Iff   => "".to_string(),
            Self::Lb    => "[".to_string(),
            Self::Lbb   => "[[".to_string(),
            Self::Ls    => "{ ".to_string(),
            Self::Lss   => "{{".to_string(),
            Self::Nl    => "\n".to_string(),
            Self::Num   => "".to_string(),
            Self::Pip   => "|".to_string(),
            Self::Rb    => "]".to_string(),
            Self::Rbb   => "]]".to_string(),
            Self::Rng   => "".to_string(),
            Self::Rs    => " }".to_string(),
            Self::Rss   => "}}".to_string(),
            Self::Sp    => " ".to_string(),
            Self::Stg   => "".to_string(),
            Self::St    => "".to_string(),
            Self::Txt   => "".to_string(),
        }
    }
}

struct Lex {
    cm:   crate::sysop::Lexium::Cm,
    dot:  crate::sysop::Lexium::Dot,
    els:  crate::sysop::Lexium::Els,
    end:  crate::sysop::Lexium::End,
    eof:  crate::sysop::Lexium::Eof,
    er:   crate::sysop::Lexium::Er,
    fld:  crate::sysop::Lexium::Fld,
    id:   crate::sysop::Lexium::Id,
    iff:  crate::sysop::Lexium::Iff,
    lb:   crate::sysop::Lexium::Lb,
    lbb:  crate::sysop::Lexium::Lbb,
    ls:   crate::sysop::Lexium::Ls,
    lss:  crate::sysop::Lexium::Lss,
    nl:   crate::sysop::Lexium::Nl,
    num:  crate::sysop::Lexium::Num,
    pip:  crate::sysop::Lexium::Pip,
    rb:   crate::sysop::Lexium::Rb ,
    rbb:  crate::sysop::Lexium::Rbb,
    rng:  crate::sysop::Lexium::Rng,
    rs:   crate::sysop::Lexium::Rs,
    rss:  crate::sysop::Lexium::Rss,
    sp:   crate::sysop::Lexium::Sp,
    stg:  crate::sysop::Lexium::Stg,
    st:   crate::sysop::Lexium::St,
    txt:  crate::sysop::Lexium::Txt,
}



struct Lex {
    cm:   Lexium::Cm,
    dot:  Lexium::Dot,
    els:  Lexium::Els,
    end:  Lexium::End,
    eof:  Lexium::Eof,
    er:   Lexium::Er,
    fld:  Lexium::Fld,
    id:   Lexium::Id,
    iff:  Lexium::Iff,
    lb:   Lexium::Lb,
    lbb:  Lexium::Lbb,
    ls:   Lexium::Ls,
    lss:  Lexium::Lss,
    nl:   Lexium::Nl,
    num:  Lexium::Num,
    pip:  Lexium::Pip,
    rb:   Lexium::Rb ,
    rbb:  Lexium::Rbb,
    rng:  Lexium::Rng,
    rs:   Lexium::Rs,
    rss:  Lexium::Rss,
    sp:   Lexium::Sp,
    stg:  Lexium::Stg,
    st:   Lexium::St,
    txt:  Lexium::Txt,
}

struct Lex {
    cm:   Cm,
    dot:  Dot,
    els:  Els,
    end:  End,
    eof:  Eof,
    er:   Er,
    fld:  Fld,
    id:   Id,
    iff:  Iff,
    lb:   Lb,
    lbb:  Lbb,
    ls:   Ls,
    lss:  Lss,
    nl:   Nl,
    num:  Num,
    pip:  Pip,
    rb:   Rb ,
    rbb:  Rbb,
    rng:  Rng,
    rs:   Rs,
    rss:  Rss,
    sp:   Sp,
    stg:  Stg,
    st:   St,
    txt:  Txt,
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
enum Lex {
    Cm(String),
    Dot(String),
    Els(String),
    End(String),
    Eof(String),
    Er(String),
    Fld(String),
    Id(String),
    Iff(String),
    Lb(String),
    Lbb(String),
    Ls(String),
    Lss(String),
    Nl(String),
    Num(String),
    Pip(String),
    Rb(String),
    Rbb(String),
    Rng(String),
    Rs(String),
    Rss(String),
    Sp(String),
    Stg(String),
    St(String),
    Txt(String),
}

impl Lex {
    fn get(&self) -> String {
        match self {
            Self::Cm(String)    => ",".to_string(),
            Self::Dot(String)   => ".".to_string(),
            Self::Els(String)   => "".to_string(),
            Self::End(String)   => "".to_string(),
            Self::Eof(String)   => "".to_string(),
            Self::Er(String)    => "".to_string(),
            Self::Fld(String)   => "".to_string(),
            Self::Id(String)    => "".to_string(),
            Self::Iff(String)   => "".to_string(),
            Self::Lb(String)    => "[".to_string(),
            Self::Lbb(String)   => "[[".to_string(),
            Self::Ls(String)    => "{ ".to_string(),
            Self::Lss(String)   => "{{".to_string(),
            Self::Nl(String)    => "\n".to_string(),
            Self::Num(String)   => "".to_string(),
            Self::Pip(String)   => "|".to_string(),
            Self::Rb(String)    => "]".to_string(),
            Self::Rbb(String)   => "]]".to_string(),
            Self::Rng(String)   => "".to_string(),
            Self::Rs(String)    => " }".to_string(),
            Self::Rss(String)   => "}}".to_string(),
            Self::Sp(String)    => " ".to_string(),
            Self::Stg(String)   => "".to_string(),
            Self::St(String)    => "".to_string(),
            Self::Txt(String)   => "".to_string(),
        }
    }
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
enum Lex {
    Cm(String),
    Dot(String),
    Els(String),
    End(String),
    Eof(String),
    Er(String),
    Fld(String),
    Id(String),
    Iff(String),
    Lb(String),
    Lbb(String),
    Ls(String),
    Lss(String),
    Nl(String),
    Num(String),
    Pip(String),
    Rb(String),
    Rbb(String),
    Rng(String),
    Rs(String),
    Rss(String),
    Sp(String),
    Stg(String),
    St(String),
    Txt(String),
}

impl Lex {
    fn get(&self) -> String {
        match self {
            Self::Cm    => ",".to_string(),
            Self::Dot   => ".".to_string(),
            Self::Els   => "".to_string(),
            Self::End   => "".to_string(),
            Self::Eof   => "".to_string(),
            Self::Er    => "".to_string(),
            Self::Fld   => "".to_string(),
            Self::Id    => "".to_string(),
            Self::Iff   => "".to_string(),
            Self::Lb    => "[".to_string(),
            Self::Lbb   => "[[".to_string(),
            Self::Ls    => "{ ".to_string(),
            Self::Lss   => "{{".to_string(),
            Self::Nl    => "\n".to_string(),
            Self::Num   => "".to_string(),
            Self::Pip   => "|".to_string(),
            Self::Rb    => "]".to_string(),
            Self::Rbb   => "]]".to_string(),
            Self::Rng   => "".to_string(),
            Self::Rs    => " }".to_string(),
            Self::Rss   => "}}".to_string(),
            Self::Sp    => " ".to_string(),
            Self::Stg   => "".to_string(),
            Self::St   => "".to_string(),
            Self::Txt   => "".to_string(),
        }
    }

}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
  № Cm:   ",".to_string(),  ‡ comma
  № Dot:  ".".to_string(),  ‡ dot
  № Els:  "".to_string(),   ‡ else
  № End:  "".to_string(),   ‡ end
  № Eof:  "".to_string(),   ‡ eof
  № Er:   "".to_string(),   ‡ Er
  № Fld:  "".to_string(),   ‡ field
  № Id:   "".to_string(),   ‡ id
  № Iff:   "".to_string(),  ‡ Iff
  № Lb:   "[".to_string(),  ‡ left bracket
  № Lbb:  "[[".to_string(), ‡ double left bracket
  № Ls:   "{ ".to_string(), ‡ left set
  № Lss:  "{{".to_string(), ‡ double left set
  № Nl:   "\n".to_string(), ‡ new line
  № Num:  "".to_string(),   ‡ number
  № Pip:  "|".to_string(),  ‡ pipe
  № Rb:   "]".to_string(),  ‡ right bracket
  № Rbb:  "]]".to_string(), ‡ double right bracket
  № Rng:  "".to_string(),   ‡ range
  № Rs:   " }".to_string(), ‡ right set
  № Rss:  "}}".to_string(), ‡ double right set
  № Sp:   " ".to_string(),  ‡ space
  № Stg:  "".to_string(),   ‡ string
  № St:  "".to_string(),    ‡ string literal
  № Txt:  "".to_string(),   ‡ raw text


•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    errorLexium     lexiumNameT = iota      // when error happens lexiumValue becomes the text of the error
    dotLexium                               // '.'
    eofLexium                               // value is text of error

    ifLexium                                // keywords: 'if', 'else' and 'end'
    elseLexium
    endLexium

    fieldLexium                             // starting with '.'
    idLexium                                // identifier

    leftMetaLexium                          // '{{'
    rghtMetaLexium                          // '}}'

    numberLexium                            // a number eg: '123.45'
    pipeLexium                              // '|'
    rangeLexium                             // keyword: 'range'

    rawStringLexium                         // raw ('') quoted string, eg: 'aaa bbb ccc ddd'
    stringLexium                            // quoted ("") string, eg: "aaa bbb ccc"
    textLexium                              // plain text
)

const (
    errorC  = "";       ifC     = "";
    dotC    = ".";      elseC   = "";
    eofC    = "";       endC    = "";

    fieldC  = "";       leftMetaC   = "{{";
    iDC     = "";       rightMetaC  = "}}";

    numberC = "";       rawStringC  = "";
    pipeC   = "|";      stringC     = "";
    rangeC  = "";       textC       = "";

    emptyRuneC  rune = 0;
    eofIntC     int = 0;
)

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•


•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
FROM REGEX

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    print!("\n🎡𐡋 removing (,\" ... \",) within single lines in a file \n");
    let loaded_string = fs::read_to_string("/usr/local/sys/rust/data/x1_data.csv").expect("check::Read Error");
    let parsed_string = remove_1_inline_quotes(loaded_string.clone());
    fs::write("/usr/local/sys/rust/data/q11_p_data.csv", &parsed_string).expect("check::Write Parse1 Error");

    print!("\n🎡𐡋 removing (,\" ... \",) across multiple lines in a file \n");
    let parsed_string = remove_2_multiline_quotes(loaded_string);
    fs::write("/usr/local/sys/rust/data/q12_p_data.csv", &parsed_string).expect("check::Write Parse4 Error");

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
fn prt_map(map: &HashMap<&str, i32>) -> String {
    print!("    HashMap: [ ");
    for (kk, vv) in map {
        print!("({}, {}), ", kk, vv);
    }
    print!("]\n");
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// count_str counts words in a String object
fn count_str(ss: &String) -> HashMap<&str, i32> {
    let mut res: HashMap<&str, i32> = HashMap::new();
    for txt in ss.split_whitespace() {
        let p_count: &mut i32 = res.entry(txt).or_insert(0);
        *p_count += 1;          // ⭐ pretty cool to change entry-values via a mutable pointer to our count value
    }
    res
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    let re = Regex::new(r"(?P<y>\d*)-(?P<m>\d*)-(?P<d>\d*)").unwrap();
    let before = "2012-03-14, 2013-01-01 and 2014-07-05";
    let after = re.replace_all(before, "$m/$d/$y");
    print!("before: {before}\n");
    print!("after:  {after}\n");

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    let re = Regex::new(r"(?m)^line \d+").unwrap();
    let m = re.find("line one\nline 2\n").unwrap();
    assert_eq!(m.as_str(), "line 2");

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
        static ref RE_REMOVE_SHORT_QUOTES: Regex = Regex::new("(?P<a>......).......(?P<b>.*)").unwrap();
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    let re = Regex::new(r"(?P<y>\d{4})-(?P<m>\d{2})-(?P<d>\d{2})").unwrap();
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
        static ref RE_REMOVE_SHORT_QUOTES: Regex = Regex::new(r#"(?P<yes1>\^.*)(?P<no>,".*",)(?P<yes2>.*$)"#).unwrap();
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    capture_across_mult_lines(loaded_string1.clone());
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    match res {
        Err(ee) => panic!("remove_quoted_fields::RegEx Error: {ee}\n"),
        Ok(ss)  => ss
    }
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
///λ replace aaa with a1a
fn repl_aaa_w_a1a(ss: String) -> String {

    lazy_static! {

        static ref RE_REPL_AAA_W_A1A: Regex = Regex::new(

    }

}
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    fs::write("/usr/local/sys/rust/data/q1_p_data.csv", ss).expect("check::Write Error");
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// use unicode_segmentation::UnicodeSegmentation;
// use lazy_static::lazy_static;
// use std::io::prelude::Path;
// use std::fmt;
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•

    let ss = read_file("q0_data.csv");      // wherever you are when you run   ∞ cargo run
    print!("File Content: \n{}\n", ss);

    let ss = read_file("../q1_data.csv");   // parent dir of curr clocation when you run   ∞ cargo run
    print!("File Content: \n{}\n", ss);
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•

data_out.txt
j.large.p
j.small.p
q1_p_data.csv
q2_p_data.csv
q3_p_data.csv
x0_data.csv
x1_data.csv

vim q01_p_data.csv  && vim q02_p_data.csv && vim q03_p_data.csv
vim q11_p_data.csv  && vim q12_p_data.csv && vim q13_p_data.csv

vim q12_p_data.csv && vim q13_p_data.csv && vim q14_p_data.csv && vim q15_p_data.csv

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
use std::fs;
fn main() -> Result<(), String> {
   let s = "a";
   match fs::read_to_string(s) {
      Ok(v) => print!("{}", v),
      // normal message is just: The system cannot find the file specified
      Err(v) => Err(format!("{} {}", s, v))?
   }
   Ok(())
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
    match check() {
        Err(ee) => panic!("{}", ee),
        _       => Ok(()),
    }
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
_ => Ok(()),     ⮕> 👎ς ^^ cannot infer type of the type parameter `E` declared on the enum `Result`
                    help: consider specifying the generic arguments | 21 |  _ => Ok::<(), E>(()),
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
        _       => Ok::<(), _>,
    match run_system() {
        Err(ee) => panic!("{}", ee),
        _       => Ok(()),
    }

* /
/ / End Of The Code Pit


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
․0․ END OF
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·







                           ·════════════════════════════··════════════════════════════··════════════════════════════·
                           ·════════════ 🔻 ════════════··════════════ 🔻 ════════════··════════════ 🔻 ════════════·
                           ·════════════════════════════··════════════════════════════··════════════════════════════·



                                         💥                            💥                            💥
                                       💥💥💥                        💥💥💥                        💥💥💥
                                         💥                            💥                            💥





                                                         ·════════════════════════════·
                                                         ·════════════ 🔻 ════════════·
                                                         ·════════════════════════════·



                                                                      💥💥
                                                                     💥  💥
                                                                      💥💥



                                                         ·════════════════════════════·
                                                         ·════════════ 🔻 ════════════·
                                                         ·════════════════════════════·





                                         💥                            💥                            💥
                                       💥💥💥                        💥💥💥                        💥💥💥
                                         💥                            💥                            💥



                           ·════════════════════════════··════════════════════════════··════════════════════════════·
                           ·════════════ 🔻 ════════════··════════════ 🔻 ════════════··════════════ 🔻 ════════════·
                           ·════════════════════════════··════════════════════════════··════════════════════════════·







·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․9․⛩κ✨λ ARCHIVE OF OLDER COMPLETE MODULES (Fwd․ Chrono)

․4․ PREAMBLE:

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
❓𐤒 QaaS ─ Questions Answers Actions § Searches

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
🔭 URLs →

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
⭐ν NOTES:



•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·

                                                                 ·════ 🔻 ════·
                                                                       💥
                                                                 ·════ 🔻 ════·

·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․✨λ✧23․01․03․ mylib::q4_fold  (Fwd․ Chrono)



// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// ✨λ mylib::q4_fold  ι✧21․12․25✦16․50․24․  🌎η ✧23․01․03․✧22․11․16․✧22․11․12․✧22․08․22․✧22․08․19․✧22․08․16․✧22․08․07․✧22․08․05․✧22․07․04․

use std::fs;
use std::collections::HashMap;

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
//λ unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// Traits, Constants, Types § Enums


pub type Map = HashMap<String, (i32, i32)>;

/// allows folding (collapsing) a list of things using methods like: count, sum, mult, etc.
pub trait Fold<Map> {

    fn new() -> Map;
    fn fold(&self) -> Option<Map>;
    fn fold_by_count(&self) -> Option<Map>;
    fn fold_by_sum(&self) -> Option<Map>;

    fn to_csv(&self, header: &str) -> Result<String, String>;
    fn to_table(&self) -> Result<String, String>;                       // data only, no header 
}

impl Fold<Map> for Map {

    fn new() -> Map {
        let res: HashMap<String, (i32, i32)> = HashMap::new();
        res
    }
    fn fold(&self) -> Option<Map> {
        let res = Map::new();
        Some(res)
    }
    fn fold_by_count(&self) -> Option<Map> {
        let res = Map::new();
        Some(res)
    }
    fn fold_by_sum(&self) -> Option<Map> { 
        let res = Map::new();
        Some(res)
    }
    fn to_csv(&self, header: &str) -> Result<String, String> { 
        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        let mut res: String = String::new();

        res = res + &header.to_string() + &nl;
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
    fn to_table(&self) -> Result<String, String> { 
        let mut res: String = String::new();

        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
}


/// map_to_csv converts a hash map to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn map_to_csv(fwd: bool, header: &str, map: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let hd: String = header.to_string();
    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    if fwd {
        res = res + &hd + &nl;
        for (kk, vv) in map {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
    } else {
        res = res + &hd + &nl;
        for (kk, vv) in map {
            res = res + &vv.0.to_string() + &cm + &vv.1.to_string() + &cm + &kk + &nl;
        }
    }
    res
}


/// map_to_table converts a hash map to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn map_to_table(map: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    for (kk, vv) in map {
        res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
    }
    res
}


///λ map_count inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn map_count(ss: String) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for line in ss.lines() {
        match res.get(line) {
            None => res.insert(line.to_string(), (0, 1)),
            Some(count) => res.insert(line.to_string(), (count.0, count.1+1)),
        };
    }
    res
}


///λ map_reduce inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn map_reduce(hm: HashMap<String, (i32, i32)>) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for (kk, _) in hm {
        match res.get(&kk) {
            None => res.insert(kk, (0, 1)),
            Some(count) => res.insert(kk, (count.0, count.1+1)),
        };
    }
    res
}


// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
///λ map_iter_1 does the first hashmap iteration of counting duplicates, i.e.:
///  1. reads table from x41_in_data.csv and runs the first hashmapping iteration 
///  2. writes the resulting hashmap to: y41_iter1_res.csv
///  3. removes the last column of the table and writes subtable to: x42_iter1_subtable.csv
pub fn map_iter()  -> Result<String, String> {

    let my_location = "map_iter_2";
    match fs::read_to_string("/usr/local/sys/sys3rs/data/x41_input_data.csv") {
        Err(ee)       => Err(format!("read_error[{ee}]@{my_location}")),

        Ok(in_string) => {
            let map1 = map_count(in_string);
            let csv1 = format!("{}\n", map_to_csv(true, "col1, col2, cnt1, cnt2", &map1));
            
            match fs::write("/usr/local/sys/sys3rs/data/y41_iter1_res.csv", &csv1) {
                Err(ee) => Err(format!("write_map_error[{ee}]@{my_location}")),
                _ => {
                    let csv1 = format!("{}\n", map_to_table(&map1));
                    
                    match fs::write("/usr/local/sys/sys3rs/data/x42_iter1_subtable.csv", &csv1) {
                        Err(ee) => Err(format!("write_key_error[{ee}]@{my_location}")),
                        Ok(()) => Ok(csv1),
                    }
                },
            }
        },
    }
}



///λ check is an integration tester (int-tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), String> {

    let my_location = "q4_fold::check";
    print!("\n🎡𐡋 {my_location} \n");
    match fs::read_to_string("/usr/local/sys/sys3rs/data/x32_in_count_duplicates.csv") {
        Err(ee)       => Err(format!("read_error[{ee}]@{my_location}")),
        Ok(in_string) => {
            let map1 = map_count(in_string);
            print!("map1:  {:?}\n", map1);
            print!("{}\n", map_to_csv(true, "Key1, Key2, cnt1, cnt2", &map1));
            Ok(())
        },
    }
    /*
    */
}


//λ The Code Pit
/*
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
///λ check is an integration tester (int-tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), String> {
    let my_location = "q4_fold::check";
    match map_iter() {
        Err(ee) => Err(format!("{ee}⟸ {my_location}")),
        _       => Ok(()),
    }
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}




use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}

type Result<T> = std::result::Result<T, std::io::Error>;

const C_LL: &str = "\n•═══════════··══════════════════·═══════════════════··═══════════•\n";

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
*/
// End Of The Code Pit



•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․✨λ✧23․01․03․ mylib::q1_lex   (Fwd․ Chrono)

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// ✨λ mylib::q1_lex  ι✧21․12․25✦16․50․24․  🌎η ✧22․11․16․✧22․11․12․✧22․08․22․✧22․08․19․✧22․08․16․✧22․08․07․✧22․08․05․✧22․07․04․✧22․06․22․

use std::env;
use std::fmt;

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
//λ unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
/// Default Strings - obj: to shorten the essential String delimiters - using explicitly derived style

#[derive(Clone)]
enum SubType {
    Cm,         // Comma
    Dot,        // Dot
    Col,        // Colon
    Els,        // Else
    End,        // End
    Eof,        // Eof
    Er,         // Error
    Fld,        // Field
    Id,         // Id
    Iff,        // If
    Lb1,        // LeftSquareBr
    Lb2,        // LeftDoubleBr
    Ls1,        // LeftCurlySqrBr
    Ls2,        // LeftDoubleCurlyBr
    Nl,         // NewLine
    Num,        // Number
    Pip,        // Pipe
    Qt1,        // DoubleQuote
    Qt2,        // SingleQuote
    Qt3,        // TikQuote
    Rb1,        // RightSquareBr
    Rb2,        // RightDoubleSqrBr
    Rng,        // Range
    Rs1,        // RightCurlyBr
    Rs2,        // RightDoubleCurlyBr
    Sp,         // Space
    Stg,        // String
    Stl,        // StrLiteral
    Txt,        // Text
}


impl SubType {

    fn name(&self) -> String {
        match self {
            SubType::Cm    => "Comma".to_string(),               
            SubType::Dot   => "Dot".to_string(),                 
            SubType::Col   => "Colon".to_string(),               
            SubType::Els   => "Else".to_string(),                
            SubType::End   => "End".to_string(),                 
            SubType::Eof   => "Eof".to_string(),                 
            SubType::Er    => "Error".to_string(),               
            SubType::Fld   => "Field".to_string(),               
            SubType::Id    => "Id".to_string(),                  
            SubType::Iff   => "If".to_string(),                  
            SubType::Lb1   => "LeftSquareBr".to_string(),        
            SubType::Lb2   => "LeftDoubleBr".to_string(),        
            SubType::Ls1   => "LeftCurlySqrBr".to_string(),      
            SubType::Ls2   => "LeftDoubleCurlyBr".to_string(),   
            SubType::Nl    => "NewLine".to_string(),             
            SubType::Num   => "Number".to_string(),              
            SubType::Pip   => "Pipe".to_string(),                
            SubType::Qt1   => "DoubleQuote".to_string(),         
            SubType::Qt2   => "SingleQuote".to_string(),         
            SubType::Qt3   => "TikQuote".to_string(),            
            SubType::Rb1   => "RightSquareBr".to_string(),       
            SubType::Rb2   => "RightDoubleSqrBr".to_string(),    
            SubType::Rng   => "Range".to_string(),               
            SubType::Rs1   => "RightCurlyBr".to_string(),        
            SubType::Rs2   => "RightDoubleCurlyBr".to_string(),  
            SubType::Sp    => "Space".to_string(),               
            SubType::Stg   => "String".to_string(),              
            SubType::Stl   => "StrLiteral".to_string(),          
            SubType::Txt   => "Text".to_string(),                
        }
    }
}


struct Lexium {
    subtype:  SubType,
    value:    String,
}



impl Lexium {
    fn new(lst: SubType) -> Self {
        Lexium {
            subtype:  lst.clone(),
            value:    Self::new_val(&lst),
        }
    }

    fn new_val(lst: &SubType) -> String {
        match lst {
            SubType::Cm    => ",".to_string(),
            SubType::Dot   => ".".to_string(),
            SubType::Col   => ":".to_string(),
            SubType::Els   => "else".to_string(),
            SubType::End   => "end".to_string(),
            SubType::Eof   => "eof".to_string(),
            SubType::Er    => "".to_string(),
            SubType::Fld   => "".to_string(),
            SubType::Id    => "".to_string(),
            SubType::Iff   => "if".to_string(),
            SubType::Lb1   => "[".to_string(),
            SubType::Lb2   => "[[".to_string(),
            SubType::Ls1   => "{".to_string(),
            SubType::Ls2   => "{{".to_string(),
            SubType::Nl    => "\n".to_string(),
            SubType::Num   => "0".to_string(),
            SubType::Pip   => "|".to_string(),
            SubType::Qt1   => "\"".to_string(),
            SubType::Qt2   => "'".to_string(),
            SubType::Qt3   => "`".to_string(),
            SubType::Rb1   => "]".to_string(),
            SubType::Rb2   => "]]".to_string(),
            SubType::Rng   => "..".to_string(),
            SubType::Rs1   => "}".to_string(),
            SubType::Rs2   => "}}".to_string(),
            SubType::Sp    => " ".to_string(),
            SubType::Stg   => "".to_string(),
            SubType::Stl   => "".to_string(),
            SubType::Txt   => "".to_string(),
        }
    }


    fn t(&self) -> SubType {
        self.subtype.clone()
    }

    fn v(&self) -> String {
        self.value.clone()
    }
}


///λ Implements Display for Lexium so we can print individual lexia the way we want
impl fmt::Display for Lexium{
    fn fmt(&self, ff: &mut fmt::Formatter) -> fmt::Result {
        write!( ff, "{}", format!("{{{}: {}}}", &self.t().name(), &self.v()) )
    }
}


pub struct Lex {
    cm:   Lexium,
    dot:  Lexium,
    col:  Lexium,
    els:  Lexium,
    end:  Lexium,
    eof:  Lexium,
    er:   Lexium,
    fld:  Lexium,
    id:   Lexium,
    iff:  Lexium,
    lb1:  Lexium,
    lb2:  Lexium,
    ls1:  Lexium,
    ls2:  Lexium,
    nl:   Lexium,
    num:  Lexium,
    pip:  Lexium,
    qt1:  Lexium,
    qt2:  Lexium,
    qt3:  Lexium,
    rb1:  Lexium,
    rb2:  Lexium,
    rng:  Lexium,
    rs1:  Lexium,
    rs2:  Lexium,
    sp:   Lexium,
    stg:  Lexium,
    stl:  Lexium,
    txt:  Lexium,
}


impl Lex {
    pub fn new() -> Self {
        Lex {
            cm:   Lexium::new(SubType::Cm),
            dot:  Lexium::new(SubType::Dot),
            col:  Lexium::new(SubType::Col),
            els:  Lexium::new(SubType::Els),
            end:  Lexium::new(SubType::End),
            eof:  Lexium::new(SubType::Eof),
            er:   Lexium::new(SubType::Er),
            fld:  Lexium::new(SubType::Fld),
            id:   Lexium::new(SubType::Id),
            iff:  Lexium::new(SubType::Iff),
            lb1:  Lexium::new(SubType::Lb1),
            lb2:  Lexium::new(SubType::Lb2),
            ls1:  Lexium::new(SubType::Ls1),
            ls2:  Lexium::new(SubType::Ls2),
            nl:   Lexium::new(SubType::Nl),
            num:  Lexium::new(SubType::Num),
            pip:  Lexium::new(SubType::Pip),
            qt1:  Lexium::new(SubType::Qt1),
            qt2:  Lexium::new(SubType::Qt2),
            qt3:  Lexium::new(SubType::Qt3),
            rb1:  Lexium::new(SubType::Rb1),
            rb2:  Lexium::new(SubType::Rb2),
            rng:  Lexium::new(SubType::Rng),
            rs1:  Lexium::new(SubType::Rs1),
            rs2:  Lexium::new(SubType::Rs2),
            sp:   Lexium::new(SubType::Sp),
            stg:  Lexium::new(SubType::Stg),
            stl:  Lexium::new(SubType::Stl),
            txt:  Lexium::new(SubType::Txt),
        }
    }
}

///λ Implements Display for Lex so we can print a lex the way we want
impl fmt::Display for Lex{
    fn fmt(&self, ff: &mut fmt::Formatter) -> fmt::Result {
        write!( ff, "[ {} ]", 
            format!("{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}", 
                &self.cm,
                &self.dot,
                &self.col,
                &self.els,
                &self.end,
                &self.eof,
                &self.er,
                &self.fld,
                &self.id,
                &self.iff,
                &self.lb1,
                &self.lb2,
                &self.ls1,
                &self.ls2,
                &self.nl,
                &self.num,
                &self.pip,
                &self.qt1,
                &self.qt2,
                &self.qt3,
                &self.rb1,
                &self.rb2,
                &self.rng,
                &self.rs1,
                &self.rs2,
                &self.sp,
                &self.stg,
                &self.stl,
                &self.txt
            )
        )
    }
}



/// prt_cmd prints the command line that was invoked to run this
pub fn prt_cmd() -> String {

    let args: Vec<String> = env::args().collect();
    let l = Lex::new();

    let mut res = l.ls1.v();
    for arg in args.iter() {
        res = res + &l.lb1.v() + arg + &l.rb1.v() + &l.sp.v();
    }
    // res = res + &l.rs.v();

    print!("\ncommand issued:   {}", res.clone() + &l.nl.v());
    res
}


///λ check is the module suppervisor (an integration tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), String> {

    /*
    */
    let my_location = "q1_lex::check";
    print!("\n🎡𐡋 {my_location} \n");
    Ok(())                                                              // don't: panic!("for: No Reason");
}


//λ The Code Pit
/*
Check scratch_pad, a lot of code framgents moved there
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•

pub fn check() -> Result<(), String> {

    let stg = prt_cmd();
    let my_location = "q1_lex::check";
    print!("{C_LL}🎡𐡋 {my_location} \n", );

    print!("🎡𐡋 prt_cmd \n");
    prt_cmd();

    let l = Lex::new();
    print!("l: Lex\n{l}");

    Ok(())
    // don't panic!("for: No Reason");
}
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
Recent Crates

mod s1_lex;                     use s1_lex::{check};
mod sysop_exec;                 use sysop_exec::{check};
mod a84_re_multiline;           use a84_re_multiline::{check};
mod a83_regex_basics;           use a83_regex_basics::{check};
mod a82_string_methods;         use a82_string_methods::{check};

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•

impl Default for Lex {
    fn default() -> Self {
        let lex = Lex::new();
        lex
    }
}

•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
*/
// End Of The Code Pit


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․✨λ  (Fwd․ Chrono)
// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// ✨λ mylib::q4_fold  ι✧21․12․25✦16․50․24․  🌎η ✧23․01․03․✧22․11․16․✧22․11․12․✧22․08․22․✧22․08․19․✧22․08․16․✧22․08․07․✧22․08․05․✧22․07․04․

use std::fs;
use std::collections::HashMap;

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
//λ unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`

// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
// Traits, Constants, Types § Enums

/// FMap is a Folding Hashmap with 2 metrics
pub type FMap = HashMap<String, (i32, i32)>;


/// allows folding (collapsing) a list of things using methods like: count, sum, mult, etc.
pub trait Fold<FMap> {

    fn new() -> FMap;
    fn init(ss: String) -> FMap;

    fn to_csv(&self, header: &str) -> Result<String, String>;
    fn to_table(&self) -> Result<String, String>;                       // data only, no header 
}


impl Fold<FMap> for FMap {

    fn new() -> FMap {
        let myself: HashMap<String, (i32, i32)> = HashMap::new();
        myself
    }
    
    fn init(ss: String) -> FMap {
        let mut myself = FMap::new();
        for line in ss.lines() {
            match myself.get(line) {
                None => myself.insert(line.to_string(), (0, 1)),
                Some(count) => myself.insert(line.to_string(), (count.0, count.1+1)),
            };
        }
        myself
    }

    fn to_csv(&self, header: &str) -> Result<String, String> { 
        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        let mut res: String = String::new();

        res = res + &header.to_string() + &nl;
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
    fn to_table(&self) -> Result<String, String> { 
        let mut res: String = String::new();

        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
}


/// fmap_to_csv converts a hash map to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn fmap_to_csv(fwd: bool, header: &str, fmap: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let hd: String = header.to_string();
    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    if fwd {
        res = res + &hd + &nl;
        for (kk, vv) in fmap {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
    } else {
        res = res + &hd + &nl;
        for (kk, vv) in fmap {
            res = res + &vv.0.to_string() + &cm + &vv.1.to_string() + &cm + &kk + &nl;
        }
    }
    res
}


/// fmap_to_table converts a hash fmap to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn fmap_to_table(fmap: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    for (kk, vv) in fmap {
        res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
    }
    res
}


///λ fmap_count inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn fmap_count(ss: String) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for line in ss.lines() {
        match res.get(line) {
            None => res.insert(line.to_string(), (0, 1)),
            Some(count) => res.insert(line.to_string(), (count.0, count.1+1)),
        };
    }
    res
}


///λ fmap_reduce inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn fmap_reduce(hm: HashMap<String, (i32, i32)>) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for (kk, _) in hm {
        match res.get(&kk) {
            None => res.insert(kk, (0, 1)),
            Some(count) => res.insert(kk, (count.0, count.1+1)),
        };
    }
    res
}


// •════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
///λ check is an integration tester (int-tester) to check functionality in the development vector (dev-vector)
/// It does the first hashmap iteration of counting duplicates, i.e.:
///  1. reads table from x41_in_data.csv and runs the first hashmapping iteration 
///  2. writes the resulting hashmap to: y41_iter1_res.csv
///  3. removes the last column of the table and writes subtable to: x42_iter1_subtable.csv
pub fn check()  -> Result<String, String> {

    let my_location = "q4_fold::check";
    match fs::read_to_string("/usr/local/sys/sys3rs/data/x41_input_data.csv") {
        Err(ee)       => Err(format!("read_error[{ee}]@{my_location}")),

        Ok(in_string) => {
            let fmap1 = fmap_count(in_string);
            let csv1 = format!("{}\n", fmap_to_csv(true, "col1, col2, cnt1, cnt2", &fmap1));
            
            match fs::write("/usr/local/sys/sys3rs/data/y41_iter1_res.csv", &csv1) {
                Err(ee) => Err(format!("write_fmap_error[{ee}]@{my_location}")),
                _ => {
                    let csv1 = format!("{}\n", fmap_to_table(&fmap1));
                    
                    match fs::write("/usr/local/sys/sys3rs/data/x42_iter1_subtable.csv", &csv1) {
                        Err(ee) => Err(format!("write_key_error[{ee}]@{my_location}")),
                        Ok(()) => Ok(csv1),
                    }
                },
            }
        },
    }
}



•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․✨λ  (Fwd․ Chrono)




•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․✨λ  (Fwd․ Chrono)




•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․✨λ  (Fwd․ Chrono)




•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․7․✨λ  (Fwd․ Chrono)


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
․1․ End of
․0․ END OF ARCHIVE OF OLDER COMPLETE MODULES (FWD․ Chrono)
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·


                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·



                                                               ·══════ 🔻 ══════·


                                                                       💥


                                                               ·══════ 🔻 ══════·



                                             ·══════ 💥 ══════··══════ 🔻 ══════··══════ 💥 ══════·


·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․4․🦢ζι✧©1991․05․01․TMP: Nomenclature § Glossary․


•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•
․3․🏛№ Header Legend:

ᚖ․this․File․Classification    Φ․this.File─Name     ᚖ․Cat1․Primary Category           ᚖ․Subj1․Primary Subjet Areas
ο․this․File․Owner─Name                             ᚖ․Cat2․Secondary Category         ᚖ․Subj2․Secondary or Specific Subjet Areas

ᚖ․File․Classification:        • Γ0․ Pub․p;  Γ1․ Int․s;    Γ2․ Conf․s;   Γ3․ Secr․s;
                              • Γ4․ TS․s;   Γ5․ Comp1․s;  Γ6․ Comp2․s;  Γ[789]․ Crypto․k;


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •                          ·                   ·                   ·                   ·            •
•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •                          ·                   ·                   ·                   ·            •
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·

                                                                 ·════ 🔻 ════·

                                                                       💥

                                                                 ·════ 🔻 ════·

·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··════════════════ 🔻 ══════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
․4․🦢ζ TMP: Staging § Footer


•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
•           ·                   ·                   ·                   ·                   ·                   ·                   ·            •
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
·═══════════··══════════════════════════════════════··══════════════════════════════════════··══════════════════════════════════════··═══════════·
─ → ⇒ ► 📎 🔑 ⭐ 💥 ⚡ 🈳 🈴 ⛩ 📐 🎡 ⏰ 🏁 ✅ 🏃 🦎 ⭕️ 🚫 👥 🖖 🖖 👍 👎 ⮕ ⬅ ⬆ ⬇          ․Jan․F․M․․Apr․M․J․․Jul․A․S․․Oct․N․D․
․4․©1991․𐍂․𐡇․𐒱lpíz𐓙r․(Rafael H. Alpizar ι․1991․05․03․) § ® ● • · 、 〞 ∞ ∅ ✝ ✔ ✘ ≙ ᚖ ⋯ ⋱ ⋰ ․A․․․B․C․․D․․․E․F․․G․․․H․I․․J․․․K․L․
•═══════════··══════════════════·═══════════════════··══════════════════·═══════════════════··══════════════════·═══════════════════··═══════════•

