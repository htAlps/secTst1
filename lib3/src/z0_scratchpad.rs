Î“0â€¤s0_scratchpad.rsâ€¤          áš–â€¤Catgâ€¤Tags: CODE, KB
â€¤â€¤Î¿â€¤ğ‚ğ“™fğ“™Îµlâ€¤ğ¡‡â€¤ğ’±lpÃ­zğ“™râ€¤         áš–â€¤Subjâ€¤Tags: Code Fragments to Support Associated Module 
Â·   Â·                           Â·

Contents:

  â„– Nomenclature, Glossary, Staging Â§ Footerâ€¤

Anouncements:


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤9â€¤â›©Îºâœ¨Î» Short Programs Â§ Code Fragments  (Revâ€¤ Chrono)

â€¤4â€¤ PREAMBLE:

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â“ğ¤’ QaaS â”€ Questions Answers Actions Â§ Searches

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
ğŸ”­ URLs â†’

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â­Î½ NOTES:


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤ÎºÎ» Short Programs (Revâ€¤ Chrono)


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¤5â€¤ 



â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·

                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·
                                                                       ğŸ’¥
                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·

Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤ÎºÎ» Short Programs (Revâ€¤ Chrono)


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¤5â€¤Î» 



â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢ 
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·

                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·
                                                                       ğŸ’¥
                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·

Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤ÎºÎ» Short Programs (Revâ€¤ Chrono)


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¤5â€¤ 



â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·

                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·
                                                                       ğŸ’¥
                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·

Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤ÎºÎ» Short Programs (Revâ€¤ Chrono)

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// âœ¨Î» s0_scratch_pad  Î¹âœ§21â€¤11â€¤22âœ¦10â€¤08â€¤26â€¤ ğŸŒÎ· âœ§22â€¤10â€¤22â€¤
#![allow(dead_code)]
extern crate regex;
use regex::Regex;
use std::error::Error;
use std::fs;
use std::fs::File;
use std::path::Path;
use std::io::Read;
use lazy_static::lazy_static;

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
//Î» unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`
#[cfg(test)]
mod test_regex {
    use super::*;

    const TEST_STR: &str = r#"\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln03: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln04: aa,   ddd3,   bb,   ccc,   ddd44,   eee,"  f,  \n\
ln05: a",   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln06: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln07: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln08: aa,   ddd3,   bb,   ccc,   ddd44,   eee,"  f,  \n\
ln09: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln10: a",   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln11: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln12: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln13: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln02: aa,   ddd1,'  bb,   ccc,   ddd2',   eee,   f,  \n\
ln01: aa,   ddd1,"  bb,   ccc,   ddd2",   ee',   f,  \n\
ln14: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln15: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln16: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
ln17: aa,   ddd3,   bb,   ccc,   ddd44,   eee,   f,  \n\
Downloaded Data (x. Prefix)                          \n\
Controlled Text for Testing RegEx Captures
"#;

    #[test]
    fn test_preamble() {
        print!("TEST_STR: {TEST_STR} \n")
    }

}

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
//Î» common functions
fn prt_chars(ss: &String) {
    print!("    ss.chars(): ");
    for val in ss.chars() {
        print!("{val} ");
    }
    print!("\n\n");
}


///Î» Read a file the old way
fn read_file(file_path: &str) -> String {

    let path = Path::new(file_path);
    print!("path.display(): {}\n", path.display());

    let mut ff = match File::open(&path) {
        Err(ee) => panic!("Open Error: {ee}\n"),
        Ok(ff)  => ff,
    };


    let mut ss = String::new();
    match ff.read_to_string(&mut ss) {
        Err(ee) => panic!("read_file::Read Error: {ee}\n"),
        Ok(_) => ss
    }
}


///Î» Capture across multiple lines
fn capture_across_mult_lines(ss: String) {

    //  â€¢â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    print!("{}ğŸ¡ğ¡‹ Checking: Capturing across multiple lines \n", C_LL);

    // first a simple patern
    let re = Regex::new(r#"(dd1)"#).unwrap();

    for cap in re.captures_iter(&ss) {
        print!("\nMatch:   {:?}\n", cap);
    }

    print!("\nğŸ¡ğ¡‹ Capture all text inside: (,' text ',)  \n");

    // ignoring all delimiters between single quotes in one line (,'  text  ',)
    let re = Regex::new(r#",'(.*)',"#).unwrap();

    for cap in re.captures_iter(&ss) {
        print!("\nMatch:   {:?}\n", cap);
    }

    print!("\nğŸ¡ğ¡‹ Capture all text inside: (,\" text \",)  \n");

    // ignoring all delimiters between double quotes in multiple lines (,"  text  ",)
    let re = Regex::new(r#"(?s),"(.*)","#).unwrap();

    for cap in re.captures_iter(&ss) {
        print!("\n\nMatch:   {:?}\n\n", cap);
    }
}


///Î» this RegEx Helper looseley ratches an IPv4 addr
fn has_ipv4(ss: &str) -> bool {

    lazy_static! {
        static ref RE_IPV4: Regex = Regex::new(r" \d\d?\d?\.\d\d?\d?\.\d\d?\d?\.\d\d?\d? ").unwrap();
    }
    RE_IPV4.is_match(ss)
}


///Î» This RegEx Helper removes (," ... ",) in a single line
fn remove_1_inline_quotes(ss: String) -> String {

    lazy_static! {
        static ref RE_REMOVE_1_INLINE_QUOTES: Regex = Regex::new(r#"(?P<yes1>.*)(?P<no>,".*",)(?P<yes2>.*)"#).unwrap();
    }
    let res = RE_REMOVE_1_INLINE_QUOTES.replace_all(&ss, "â‰º1:$yes1â‰»,--removed_inline_quotation--,â‰º2:$yes2â‰»");
    res.to_string()
}


///Î» This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_2_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_2_MULTILINE_QUOTES: Regex = Regex::new(r#"((?ms:.)(?P<yes1>.*)(?P<no>,".*",)(?P<yes2>.*))"#).unwrap();
    }
    let res = RE_REMOVE_2_MULTILINE_QUOTES.replace_all(&ss, "â‰º1:$yes1â‰»,--removed_multiline_quotation--,â‰º2:$yes2â‰»");
    res.to_string()
}


///Î» This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_3_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_3_MULTILINE_QUOTES: Regex = Regex::new(r#"((?P<yes1>(?ms:.).*)(?P<no>,".*",)(?P<yes2>.*))"#).unwrap();
    }
    let res = RE_REMOVE_3_MULTILINE_QUOTES.replace_all(&ss, "â‰º1:$yes1â‰»,--removed_multiline_quotation--,â‰º2:$yes2â‰»");
    res.to_string()
}


///â­Î½Î» This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_4_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_4_MULTILINE_QUOTES: Regex = Regex::new(r#"((?P<yes1>.*)(?P<no>(?ms:,".*?",))(?P<yes2>.*))"#).unwrap();
    }
    let res = RE_REMOVE_4_MULTILINE_QUOTES.replace_all(&ss, "â‰º1:$yes1â‰»,--removed_quoted_field--,â‰º2:$yes2â‰»");
    res.to_string()
}


///Î» This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_5_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_5_MULTILINE_QUOTES: Regex = Regex::new(r#"((?P<yes1>.*)(?P<no>,".*",)(?P<yes2>(?ms:.).*))"#).unwrap();
    }
    let res = RE_REMOVE_5_MULTILINE_QUOTES.replace_all(&ss, "â‰º1:$yes1â‰»,--removed_multiline_quotation--,â‰º2:$yes2â‰»");
    res.to_string()
}


///Î» This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n in entire regex
fn remove_7_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_7_MULTILINE_QUOTES: Regex = Regex::new(r#"((?m)(?s:.)(?P<yes1>(?m).*)(?P<no>(?m),".*",)(?P<yes2>(?m).*))"#).unwrap();
    }
    let res = RE_REMOVE_7_MULTILINE_QUOTES.replace_all(&ss, "â‰º1:$yes1â‰»,--removed_multiline_quotation--,â‰º2:$yes2â‰»");
    res.to_string()
}


///Î» This RegEx Helper removes (," ... ",) across multiple lines - this one matches \n only in <no>
fn remove_8_multiline_quotes(ss: String) -> String {

    lazy_static! {                                                          //    `(?m)` = multi-line mode
        static ref RE_REMOVE_8_MULTILINE_QUOTES: Regex = Regex::new(r#"((?m)(?P<yes1>(?m).*)(?s:.)(?P<no>(?m),".*",)(?P<yes2>(?m).*))"#).unwrap();
    }
    let res = RE_REMOVE_8_MULTILINE_QUOTES.replace_all(&ss, "â‰º1:$yes1â‰»,--removed_multiline_quotation--,â‰º2:$yes2â‰»");
    res.to_string()
}


///Î» check_regex_helpers checks functionality in the in the development vector
pub fn check_regex_helpers() {
    // print!("{}ğŸ¡ğ¡‹ checking regex helpers  \n\n", C_LL);

    let loaded_string1 = fs::read_to_string("/usr/local/sys/rust/data/x1_data.csv").expect("check::Read Error");
    let parsed_string = remove_1_inline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q11_p_data.csv", &parsed_string).expect("check::Write Parse1 Error");

    let parsed_string = remove_2_multiline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q12_p_data.csv", &parsed_string).expect("check::Write Parse2 Error");

    let parsed_string = remove_3_multiline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q13_p_data.csv", &parsed_string).expect("check::Write Parse3 Error");

    let parsed_string = remove_4_multiline_quotes(loaded_string1.clone());
    fs::write("/usr/local/sys/rust/data/q14_p_data.csv", &parsed_string).expect("check::Write Parse4 Error");

    let parsed_string = remove_5_multiline_quotes(loaded_string1);
    fs::write("/usr/local/sys/rust/data/q15_p_data.csv", &parsed_string).expect("check::Write Parse5 Error");

    let re = Regex::new(r"(?m)^line \d+").unwrap();
    let m = re.find("line one\nline 2\n").unwrap();
    assert_eq!(m.as_str(), "line 2");

    let re = Regex::new(r"(?m)^line \d+").unwrap();
    let m = re.find("line one\nline 2\n").unwrap();
    assert_eq!(m.as_str(), "line 2");
}



// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// Constants Types Â§ Enums

const C_LL: &str = "\nâ€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢\n";

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
///Î» check is the integration test executive function for this module
pub fn check() -> Result<(), String> {
    // print!("{}ğŸ¡ğ¡‹ Checking: s1_exec  \n\n", C_LL);

    check_regex_helpers();

    Ok(())
    // panic!("for: No Reason");
}



â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of Regular Code 
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·


Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤ÎºÎ» The Code Pit 

/// The Code Pit
/ *

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    print!("ğŸ¡ğ¡‹ {my_location} \n");
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
///Î» OLD VERSION c2_string_methods::check is the module suppervisor (an integration tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), Box<dyn Error>> {
    let my_location = "c2_string_methods::check";
    print!("ğŸ¡ğ¡‹ {my_location} \n");

    str_basics();
    unicode_basics();
    string_methods_basic();
    string_methods_interm();

    Ok(())
    // don't panic!("for: No Reason");
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
///Î» DEPRECATED - Implements Display for Lex so we can print a lex the way we want
impl fmt::Display for Lex{
    fn fmt(&self, ff: &mut fmt::Formatter) -> fmt::Result {
        let l = Lex::new();
        let mut res = String::new();
        res = res + &l.lb1.v();
        res = res + &l.ls1.v() + &self.cm.t().name()  + &l.sp.v() + &self.cm.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.dot.t().name() + &l.sp.v() + &self.dot.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.col.t().name() + &l.sp.v() + &self.col.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.els.t().name() + &l.sp.v() + &self.els.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.end.t().name() + &l.sp.v() + &self.end.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.eof.t().name() + &l.sp.v() + &self.eof.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.er.t().name()  + &l.sp.v() + &self.er.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.fld.t().name() + &l.sp.v() + &self.fld.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.id.t().name()  + &l.sp.v() + &self.id.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.iff.t().name() + &l.sp.v() + &self.iff.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.lb1.t().name() + &l.sp.v() + &self.lb1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.lb2.t().name() + &l.sp.v() + &self.lb2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.ls1.t().name() + &l.sp.v() + &self.ls1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.ls2.t().name() + &l.sp.v() + &self.ls2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.nl.t().name()  + &l.sp.v() + &self.nl.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.num.t().name() + &l.sp.v() + &self.num.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.pip.t().name() + &l.sp.v() + &self.pip.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.qt1.t().name() + &l.sp.v() + &self.qt1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.qt2.t().name() + &l.sp.v() + &self.qt2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.qt3.t().name() + &l.sp.v() + &self.qt3.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rb1.t().name() + &l.sp.v() + &self.rb1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rb2.t().name() + &l.sp.v() + &self.rb2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rng.t().name() + &l.sp.v() + &self.rng.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rs1.t().name() + &l.sp.v() + &self.rs1.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.rs2.t().name() + &l.sp.v() + &self.rs2.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.sp.t().name()  + &l.sp.v() + &self.sp.v()  + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.stg.t().name() + &l.sp.v() + &self.stg.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.stl.t().name() + &l.sp.v() + &self.stl.v() + &l.rs1.v() + &l.cm.v();
        res = res + &l.ls1.v() + &self.txt.t().name() + &l.sp.v() + &self.txt.v() + &l.rs1.v();
        res = res + &l.rb1.v();
        write!(ff, "{res}")
    }
}



â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â­Î½Î» OLD a83_regex_basics::mod_main NOTE THE BOX<DYN ERROR> 
pub fn mod_main() -> Result<(), Box<dyn Error>> {
    print!("{}ğŸ¡ğ¡‹ Checking: a83_regex_basics \n\n", C_LL);

    // regex_basics();
    // regex_helpers();
    // regex_iterations();

    capture_across_mult_lines();


    Ok(())
    // don't panic!("for: No Reason");
}

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
//Î» OLD c2_string_methods::mod_main
pub fn mod_main() -> Result<(), Box<dyn Error>> {
    print!("{}ğŸ¡ğ¡‹ Checking: a83_regex_basics \n\n", C_LL);

    // regex_basics();
    // regex_helpers();
    // regex_iterations();

    capture_across_mult_lines();


    Ok(())
    // don't panic!("for: No Reason");
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
const C_LL: &str = "\nâ€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢\n";
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
FROM LEXER
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
enum Lexium {
    Cm,
    Dot,
    Els,
    End,
    Eof,
    Er,
    Fld,
    Id,
    Iff,
    Lb,
    Lbb,
    Ls,
    Lss,
    Nl,
    Num,
    Pip,
    Rb,
    Rbb,
    Rng,
    Rs,
    Rss,
    Sp,
    Stg,
    st,
    Txt,
}

impl Lexium {
    fn new(&self) -> String {
        match self {
            Self::Cm    => ",".to_string(),
            Self::Dot   => ".".to_string(),
            Self::Els   => "".to_string(),
            Self::End   => "".to_string(),
            Self::Eof   => "".to_string(),
            Self::Er    => "".to_string(),
            Self::Fld   => "".to_string(),
            Self::Id    => "".to_string(),
            Self::Iff   => "".to_string(),
            Self::Lb    => "[".to_string(),
            Self::Lbb   => "[[".to_string(),
            Self::Ls    => "{ ".to_string(),
            Self::Lss   => "{{".to_string(),
            Self::Nl    => "\n".to_string(),
            Self::Num   => "".to_string(),
            Self::Pip   => "|".to_string(),
            Self::Rb    => "]".to_string(),
            Self::Rbb   => "]]".to_string(),
            Self::Rng   => "".to_string(),
            Self::Rs    => " }".to_string(),
            Self::Rss   => "}}".to_string(),
            Self::Sp    => " ".to_string(),
            Self::Stg   => "".to_string(),
            Self::St    => "".to_string(),
            Self::Txt   => "".to_string(),
        }
    }
}

struct Lex {
    cm:   crate::sysop::Lexium::Cm,
    dot:  crate::sysop::Lexium::Dot,
    els:  crate::sysop::Lexium::Els,
    end:  crate::sysop::Lexium::End,
    eof:  crate::sysop::Lexium::Eof,
    er:   crate::sysop::Lexium::Er,
    fld:  crate::sysop::Lexium::Fld,
    id:   crate::sysop::Lexium::Id,
    iff:  crate::sysop::Lexium::Iff,
    lb:   crate::sysop::Lexium::Lb,
    lbb:  crate::sysop::Lexium::Lbb,
    ls:   crate::sysop::Lexium::Ls,
    lss:  crate::sysop::Lexium::Lss,
    nl:   crate::sysop::Lexium::Nl,
    num:  crate::sysop::Lexium::Num,
    pip:  crate::sysop::Lexium::Pip,
    rb:   crate::sysop::Lexium::Rb ,
    rbb:  crate::sysop::Lexium::Rbb,
    rng:  crate::sysop::Lexium::Rng,
    rs:   crate::sysop::Lexium::Rs,
    rss:  crate::sysop::Lexium::Rss,
    sp:   crate::sysop::Lexium::Sp,
    stg:  crate::sysop::Lexium::Stg,
    st:   crate::sysop::Lexium::St,
    txt:  crate::sysop::Lexium::Txt,
}



struct Lex {
    cm:   Lexium::Cm,
    dot:  Lexium::Dot,
    els:  Lexium::Els,
    end:  Lexium::End,
    eof:  Lexium::Eof,
    er:   Lexium::Er,
    fld:  Lexium::Fld,
    id:   Lexium::Id,
    iff:  Lexium::Iff,
    lb:   Lexium::Lb,
    lbb:  Lexium::Lbb,
    ls:   Lexium::Ls,
    lss:  Lexium::Lss,
    nl:   Lexium::Nl,
    num:  Lexium::Num,
    pip:  Lexium::Pip,
    rb:   Lexium::Rb ,
    rbb:  Lexium::Rbb,
    rng:  Lexium::Rng,
    rs:   Lexium::Rs,
    rss:  Lexium::Rss,
    sp:   Lexium::Sp,
    stg:  Lexium::Stg,
    st:   Lexium::St,
    txt:  Lexium::Txt,
}

struct Lex {
    cm:   Cm,
    dot:  Dot,
    els:  Els,
    end:  End,
    eof:  Eof,
    er:   Er,
    fld:  Fld,
    id:   Id,
    iff:  Iff,
    lb:   Lb,
    lbb:  Lbb,
    ls:   Ls,
    lss:  Lss,
    nl:   Nl,
    num:  Num,
    pip:  Pip,
    rb:   Rb ,
    rbb:  Rbb,
    rng:  Rng,
    rs:   Rs,
    rss:  Rss,
    sp:   Sp,
    stg:  Stg,
    st:   St,
    txt:  Txt,
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
enum Lex {
    Cm(String),
    Dot(String),
    Els(String),
    End(String),
    Eof(String),
    Er(String),
    Fld(String),
    Id(String),
    Iff(String),
    Lb(String),
    Lbb(String),
    Ls(String),
    Lss(String),
    Nl(String),
    Num(String),
    Pip(String),
    Rb(String),
    Rbb(String),
    Rng(String),
    Rs(String),
    Rss(String),
    Sp(String),
    Stg(String),
    St(String),
    Txt(String),
}

impl Lex {
    fn get(&self) -> String {
        match self {
            Self::Cm(String)    => ",".to_string(),
            Self::Dot(String)   => ".".to_string(),
            Self::Els(String)   => "".to_string(),
            Self::End(String)   => "".to_string(),
            Self::Eof(String)   => "".to_string(),
            Self::Er(String)    => "".to_string(),
            Self::Fld(String)   => "".to_string(),
            Self::Id(String)    => "".to_string(),
            Self::Iff(String)   => "".to_string(),
            Self::Lb(String)    => "[".to_string(),
            Self::Lbb(String)   => "[[".to_string(),
            Self::Ls(String)    => "{ ".to_string(),
            Self::Lss(String)   => "{{".to_string(),
            Self::Nl(String)    => "\n".to_string(),
            Self::Num(String)   => "".to_string(),
            Self::Pip(String)   => "|".to_string(),
            Self::Rb(String)    => "]".to_string(),
            Self::Rbb(String)   => "]]".to_string(),
            Self::Rng(String)   => "".to_string(),
            Self::Rs(String)    => " }".to_string(),
            Self::Rss(String)   => "}}".to_string(),
            Self::Sp(String)    => " ".to_string(),
            Self::Stg(String)   => "".to_string(),
            Self::St(String)    => "".to_string(),
            Self::Txt(String)   => "".to_string(),
        }
    }
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
enum Lex {
    Cm(String),
    Dot(String),
    Els(String),
    End(String),
    Eof(String),
    Er(String),
    Fld(String),
    Id(String),
    Iff(String),
    Lb(String),
    Lbb(String),
    Ls(String),
    Lss(String),
    Nl(String),
    Num(String),
    Pip(String),
    Rb(String),
    Rbb(String),
    Rng(String),
    Rs(String),
    Rss(String),
    Sp(String),
    Stg(String),
    St(String),
    Txt(String),
}

impl Lex {
    fn get(&self) -> String {
        match self {
            Self::Cm    => ",".to_string(),
            Self::Dot   => ".".to_string(),
            Self::Els   => "".to_string(),
            Self::End   => "".to_string(),
            Self::Eof   => "".to_string(),
            Self::Er    => "".to_string(),
            Self::Fld   => "".to_string(),
            Self::Id    => "".to_string(),
            Self::Iff   => "".to_string(),
            Self::Lb    => "[".to_string(),
            Self::Lbb   => "[[".to_string(),
            Self::Ls    => "{ ".to_string(),
            Self::Lss   => "{{".to_string(),
            Self::Nl    => "\n".to_string(),
            Self::Num   => "".to_string(),
            Self::Pip   => "|".to_string(),
            Self::Rb    => "]".to_string(),
            Self::Rbb   => "]]".to_string(),
            Self::Rng   => "".to_string(),
            Self::Rs    => " }".to_string(),
            Self::Rss   => "}}".to_string(),
            Self::Sp    => " ".to_string(),
            Self::Stg   => "".to_string(),
            Self::St   => "".to_string(),
            Self::Txt   => "".to_string(),
        }
    }

}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
  â„– Cm:   ",".to_string(),  â€¡ comma
  â„– Dot:  ".".to_string(),  â€¡ dot
  â„– Els:  "".to_string(),   â€¡ else
  â„– End:  "".to_string(),   â€¡ end
  â„– Eof:  "".to_string(),   â€¡ eof
  â„– Er:   "".to_string(),   â€¡ Er
  â„– Fld:  "".to_string(),   â€¡ field
  â„– Id:   "".to_string(),   â€¡ id
  â„– Iff:   "".to_string(),  â€¡ Iff
  â„– Lb:   "[".to_string(),  â€¡ left bracket
  â„– Lbb:  "[[".to_string(), â€¡ double left bracket
  â„– Ls:   "{ ".to_string(), â€¡ left set
  â„– Lss:  "{{".to_string(), â€¡ double left set
  â„– Nl:   "\n".to_string(), â€¡ new line
  â„– Num:  "".to_string(),   â€¡ number
  â„– Pip:  "|".to_string(),  â€¡ pipe
  â„– Rb:   "]".to_string(),  â€¡ right bracket
  â„– Rbb:  "]]".to_string(), â€¡ double right bracket
  â„– Rng:  "".to_string(),   â€¡ range
  â„– Rs:   " }".to_string(), â€¡ right set
  â„– Rss:  "}}".to_string(), â€¡ double right set
  â„– Sp:   " ".to_string(),  â€¡ space
  â„– Stg:  "".to_string(),   â€¡ string
  â„– St:  "".to_string(),    â€¡ string literal
  â„– Txt:  "".to_string(),   â€¡ raw text


â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    errorLexium     lexiumNameT = iota      // when error happens lexiumValue becomes the text of the error
    dotLexium                               // '.'
    eofLexium                               // value is text of error

    ifLexium                                // keywords: 'if', 'else' and 'end'
    elseLexium
    endLexium

    fieldLexium                             // starting with '.'
    idLexium                                // identifier

    leftMetaLexium                          // '{{'
    rghtMetaLexium                          // '}}'

    numberLexium                            // a number eg: '123.45'
    pipeLexium                              // '|'
    rangeLexium                             // keyword: 'range'

    rawStringLexium                         // raw ('') quoted string, eg: 'aaa bbb ccc ddd'
    stringLexium                            // quoted ("") string, eg: "aaa bbb ccc"
    textLexium                              // plain text
)

const (
    errorC  = "";       ifC     = "";
    dotC    = ".";      elseC   = "";
    eofC    = "";       endC    = "";

    fieldC  = "";       leftMetaC   = "{{";
    iDC     = "";       rightMetaC  = "}}";

    numberC = "";       rawStringC  = "";
    pipeC   = "|";      stringC     = "";
    rangeC  = "";       textC       = "";

    emptyRuneC  rune = 0;
    eofIntC     int = 0;
)

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢


â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
FROM REGEX

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    print!("\nğŸ¡ğ¡‹ removing (,\" ... \",) within single lines in a file \n");
    let loaded_string = fs::read_to_string("/usr/local/sys/rust/data/x1_data.csv").expect("check::Read Error");
    let parsed_string = remove_1_inline_quotes(loaded_string.clone());
    fs::write("/usr/local/sys/rust/data/q11_p_data.csv", &parsed_string).expect("check::Write Parse1 Error");

    print!("\nğŸ¡ğ¡‹ removing (,\" ... \",) across multiple lines in a file \n");
    let parsed_string = remove_2_multiline_quotes(loaded_string);
    fs::write("/usr/local/sys/rust/data/q12_p_data.csv", &parsed_string).expect("check::Write Parse4 Error");

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
fn prt_map(map: &HashMap<&str, i32>) -> String {
    print!("    HashMap: [ ");
    for (kk, vv) in map {
        print!("({}, {}), ", kk, vv);
    }
    print!("]\n");
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// count_str counts words in a String object
fn count_str(ss: &String) -> HashMap<&str, i32> {
    let mut res: HashMap<&str, i32> = HashMap::new();
    for txt in ss.split_whitespace() {
        let p_count: &mut i32 = res.entry(txt).or_insert(0);
        *p_count += 1;          // â­ pretty cool to change entry-values via a mutable pointer to our count value
    }
    res
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    let re = Regex::new(r"(?P<y>\d*)-(?P<m>\d*)-(?P<d>\d*)").unwrap();
    let before = "2012-03-14, 2013-01-01 and 2014-07-05";
    let after = re.replace_all(before, "$m/$d/$y");
    print!("before: {before}\n");
    print!("after:  {after}\n");

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    let re = Regex::new(r"(?m)^line \d+").unwrap();
    let m = re.find("line one\nline 2\n").unwrap();
    assert_eq!(m.as_str(), "line 2");

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
        static ref RE_REMOVE_SHORT_QUOTES: Regex = Regex::new("(?P<a>......).......(?P<b>.*)").unwrap();
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    let re = Regex::new(r"(?P<y>\d{4})-(?P<m>\d{2})-(?P<d>\d{2})").unwrap();
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
        static ref RE_REMOVE_SHORT_QUOTES: Regex = Regex::new(r#"(?P<yes1>\^.*)(?P<no>,".*",)(?P<yes2>.*$)"#).unwrap();
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    capture_across_mult_lines(loaded_string1.clone());
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    match res {
        Err(ee) => panic!("remove_quoted_fields::RegEx Error: {ee}\n"),
        Ok(ss)  => ss
    }
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
///Î» replace aaa with a1a
fn repl_aaa_w_a1a(ss: String) -> String {

    lazy_static! {

        static ref RE_REPL_AAA_W_A1A: Regex = Regex::new(

    }

}
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    fs::write("/usr/local/sys/rust/data/q1_p_data.csv", ss).expect("check::Write Error");
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// use unicode_segmentation::UnicodeSegmentation;
// use lazy_static::lazy_static;
// use std::io::prelude::Path;
// use std::fmt;
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢

    let ss = read_file("q0_data.csv");      // wherever you are when you run   âˆ cargo run
    print!("File Content: \n{}\n", ss);

    let ss = read_file("../q1_data.csv");   // parent dir of curr clocation when you run   âˆ cargo run
    print!("File Content: \n{}\n", ss);
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢

data_out.txt
j.large.p
j.small.p
q1_p_data.csv
q2_p_data.csv
q3_p_data.csv
x0_data.csv
x1_data.csv

vim q01_p_data.csv  && vim q02_p_data.csv && vim q03_p_data.csv
vim q11_p_data.csv  && vim q12_p_data.csv && vim q13_p_data.csv

vim q12_p_data.csv && vim q13_p_data.csv && vim q14_p_data.csv && vim q15_p_data.csv

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
use std::fs;
fn main() -> Result<(), String> {
   let s = "a";
   match fs::read_to_string(s) {
      Ok(v) => print!("{}", v),
      // normal message is just: The system cannot find the file specified
      Err(v) => Err(format!("{} {}", s, v))?
   }
   Ok(())
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
    match check() {
        Err(ee) => panic!("{}", ee),
        _       => Ok(()),
    }
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
_ => Ok(()),     â®•> ğŸ‘Ï‚ ^^ cannot infer type of the type parameter `E` declared on the enum `Result`
                    help: consider specifying the generic arguments | 21 |  _ => Ok::<(), E>(()),
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
        _       => Ok::<(), _>,
    match run_system() {
        Err(ee) => panic!("{}", ee),
        _       => Ok(()),
    }

* /
/ / End Of The Code Pit


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
â€¤0â€¤ END OF
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·







                           Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·
                           Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·
                           Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·



                                         ğŸ’¥                            ğŸ’¥                            ğŸ’¥
                                       ğŸ’¥ğŸ’¥ğŸ’¥                        ğŸ’¥ğŸ’¥ğŸ’¥                        ğŸ’¥ğŸ’¥ğŸ’¥
                                         ğŸ’¥                            ğŸ’¥                            ğŸ’¥





                                                         Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·
                                                         Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·
                                                         Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·



                                                                      ğŸ’¥ğŸ’¥
                                                                     ğŸ’¥  ğŸ’¥
                                                                      ğŸ’¥ğŸ’¥



                                                         Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·
                                                         Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·
                                                         Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·





                                         ğŸ’¥                            ğŸ’¥                            ğŸ’¥
                                       ğŸ’¥ğŸ’¥ğŸ’¥                        ğŸ’¥ğŸ’¥ğŸ’¥                        ğŸ’¥ğŸ’¥ğŸ’¥
                                         ğŸ’¥                            ğŸ’¥                            ğŸ’¥



                           Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·
                           Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•Â·
                           Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·







Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤9â€¤â›©Îºâœ¨Î» ARCHIVE OF OLDER COMPLETE MODULES (Fwdâ€¤ Chrono)

â€¤4â€¤ PREAMBLE:

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â“ğ¤’ QaaS â”€ Questions Answers Actions Â§ Searches

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
ğŸ”­ URLs â†’

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â­Î½ NOTES:



â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·

                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·
                                                                       ğŸ’¥
                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·

Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤âœ¨Î»âœ§23â€¤01â€¤03â€¤ mylib::q4_fold  (Fwdâ€¤ Chrono)



// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// âœ¨Î» mylib::q4_fold  Î¹âœ§21â€¤12â€¤25âœ¦16â€¤50â€¤24â€¤  ğŸŒÎ· âœ§23â€¤01â€¤03â€¤âœ§22â€¤11â€¤16â€¤âœ§22â€¤11â€¤12â€¤âœ§22â€¤08â€¤22â€¤âœ§22â€¤08â€¤19â€¤âœ§22â€¤08â€¤16â€¤âœ§22â€¤08â€¤07â€¤âœ§22â€¤08â€¤05â€¤âœ§22â€¤07â€¤04â€¤

use std::fs;
use std::collections::HashMap;

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
//Î» unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// Traits, Constants, Types Â§ Enums


pub type Map = HashMap<String, (i32, i32)>;

/// allows folding (collapsing) a list of things using methods like: count, sum, mult, etc.
pub trait Fold<Map> {

    fn new() -> Map;
    fn fold(&self) -> Option<Map>;
    fn fold_by_count(&self) -> Option<Map>;
    fn fold_by_sum(&self) -> Option<Map>;

    fn to_csv(&self, header: &str) -> Result<String, String>;
    fn to_table(&self) -> Result<String, String>;                       // data only, no header 
}

impl Fold<Map> for Map {

    fn new() -> Map {
        let res: HashMap<String, (i32, i32)> = HashMap::new();
        res
    }
    fn fold(&self) -> Option<Map> {
        let res = Map::new();
        Some(res)
    }
    fn fold_by_count(&self) -> Option<Map> {
        let res = Map::new();
        Some(res)
    }
    fn fold_by_sum(&self) -> Option<Map> { 
        let res = Map::new();
        Some(res)
    }
    fn to_csv(&self, header: &str) -> Result<String, String> { 
        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        let mut res: String = String::new();

        res = res + &header.to_string() + &nl;
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
    fn to_table(&self) -> Result<String, String> { 
        let mut res: String = String::new();

        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
}


/// map_to_csv converts a hash map to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn map_to_csv(fwd: bool, header: &str, map: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let hd: String = header.to_string();
    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    if fwd {
        res = res + &hd + &nl;
        for (kk, vv) in map {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
    } else {
        res = res + &hd + &nl;
        for (kk, vv) in map {
            res = res + &vv.0.to_string() + &cm + &vv.1.to_string() + &cm + &kk + &nl;
        }
    }
    res
}


/// map_to_table converts a hash map to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn map_to_table(map: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    for (kk, vv) in map {
        res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
    }
    res
}


///Î» map_count inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn map_count(ss: String) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for line in ss.lines() {
        match res.get(line) {
            None => res.insert(line.to_string(), (0, 1)),
            Some(count) => res.insert(line.to_string(), (count.0, count.1+1)),
        };
    }
    res
}


///Î» map_reduce inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn map_reduce(hm: HashMap<String, (i32, i32)>) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for (kk, _) in hm {
        match res.get(&kk) {
            None => res.insert(kk, (0, 1)),
            Some(count) => res.insert(kk, (count.0, count.1+1)),
        };
    }
    res
}


// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
///Î» map_iter_1 does the first hashmap iteration of counting duplicates, i.e.:
///  1. reads table from x41_in_data.csv and runs the first hashmapping iteration 
///  2. writes the resulting hashmap to: y41_iter1_res.csv
///  3. removes the last column of the table and writes subtable to: x42_iter1_subtable.csv
pub fn map_iter()  -> Result<String, String> {

    let my_location = "map_iter_2";
    match fs::read_to_string("/usr/local/sys/sys3rs/data/x41_input_data.csv") {
        Err(ee)       => Err(format!("read_error[{ee}]@{my_location}")),

        Ok(in_string) => {
            let map1 = map_count(in_string);
            let csv1 = format!("{}\n", map_to_csv(true, "col1, col2, cnt1, cnt2", &map1));
            
            match fs::write("/usr/local/sys/sys3rs/data/y41_iter1_res.csv", &csv1) {
                Err(ee) => Err(format!("write_map_error[{ee}]@{my_location}")),
                _ => {
                    let csv1 = format!("{}\n", map_to_table(&map1));
                    
                    match fs::write("/usr/local/sys/sys3rs/data/x42_iter1_subtable.csv", &csv1) {
                        Err(ee) => Err(format!("write_key_error[{ee}]@{my_location}")),
                        Ok(()) => Ok(csv1),
                    }
                },
            }
        },
    }
}



///Î» check is an integration tester (int-tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), String> {

    let my_location = "q4_fold::check";
    print!("\nğŸ¡ğ¡‹ {my_location} \n");
    match fs::read_to_string("/usr/local/sys/sys3rs/data/x32_in_count_duplicates.csv") {
        Err(ee)       => Err(format!("read_error[{ee}]@{my_location}")),
        Ok(in_string) => {
            let map1 = map_count(in_string);
            print!("map1:  {:?}\n", map1);
            print!("{}\n", map_to_csv(true, "Key1, Key2, cnt1, cnt2", &map1));
            Ok(())
        },
    }
    /*
    */
}


//Î» The Code Pit
/*
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
///Î» check is an integration tester (int-tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), String> {
    let my_location = "q4_fold::check";
    match map_iter() {
        Err(ee) => Err(format!("{ee}âŸ¸ {my_location}")),
        _       => Ok(()),
    }
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}




use std::fmt::Display;

struct Pair<T> {
    x: T,
    y: T,
}

impl<T> Pair<T> {
    fn new(x: T, y: T) -> Self {
        Self { x, y }
    }
}

impl<T: Display + PartialOrd> Pair<T> {
    fn cmp_display(&self) {
        if self.x >= self.y {
            println!("The largest member is x = {}", self.x);
        } else {
            println!("The largest member is y = {}", self.y);
        }
    }
}

type Result<T> = std::result::Result<T, std::io::Error>;

const C_LL: &str = "\nâ€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢\n";

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
*/
// End Of The Code Pit



â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤âœ¨Î»âœ§23â€¤01â€¤03â€¤ mylib::q1_lex   (Fwdâ€¤ Chrono)

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// âœ¨Î» mylib::q1_lex  Î¹âœ§21â€¤12â€¤25âœ¦16â€¤50â€¤24â€¤  ğŸŒÎ· âœ§22â€¤11â€¤16â€¤âœ§22â€¤11â€¤12â€¤âœ§22â€¤08â€¤22â€¤âœ§22â€¤08â€¤19â€¤âœ§22â€¤08â€¤16â€¤âœ§22â€¤08â€¤07â€¤âœ§22â€¤08â€¤05â€¤âœ§22â€¤07â€¤04â€¤âœ§22â€¤06â€¤22â€¤

use std::env;
use std::fmt;

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
//Î» unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
/// Default Strings - obj: to shorten the essential String delimiters - using explicitly derived style

#[derive(Clone)]
enum SubType {
    Cm,         // Comma
    Dot,        // Dot
    Col,        // Colon
    Els,        // Else
    End,        // End
    Eof,        // Eof
    Er,         // Error
    Fld,        // Field
    Id,         // Id
    Iff,        // If
    Lb1,        // LeftSquareBr
    Lb2,        // LeftDoubleBr
    Ls1,        // LeftCurlySqrBr
    Ls2,        // LeftDoubleCurlyBr
    Nl,         // NewLine
    Num,        // Number
    Pip,        // Pipe
    Qt1,        // DoubleQuote
    Qt2,        // SingleQuote
    Qt3,        // TikQuote
    Rb1,        // RightSquareBr
    Rb2,        // RightDoubleSqrBr
    Rng,        // Range
    Rs1,        // RightCurlyBr
    Rs2,        // RightDoubleCurlyBr
    Sp,         // Space
    Stg,        // String
    Stl,        // StrLiteral
    Txt,        // Text
}


impl SubType {

    fn name(&self) -> String {
        match self {
            SubType::Cm    => "Comma".to_string(),               
            SubType::Dot   => "Dot".to_string(),                 
            SubType::Col   => "Colon".to_string(),               
            SubType::Els   => "Else".to_string(),                
            SubType::End   => "End".to_string(),                 
            SubType::Eof   => "Eof".to_string(),                 
            SubType::Er    => "Error".to_string(),               
            SubType::Fld   => "Field".to_string(),               
            SubType::Id    => "Id".to_string(),                  
            SubType::Iff   => "If".to_string(),                  
            SubType::Lb1   => "LeftSquareBr".to_string(),        
            SubType::Lb2   => "LeftDoubleBr".to_string(),        
            SubType::Ls1   => "LeftCurlySqrBr".to_string(),      
            SubType::Ls2   => "LeftDoubleCurlyBr".to_string(),   
            SubType::Nl    => "NewLine".to_string(),             
            SubType::Num   => "Number".to_string(),              
            SubType::Pip   => "Pipe".to_string(),                
            SubType::Qt1   => "DoubleQuote".to_string(),         
            SubType::Qt2   => "SingleQuote".to_string(),         
            SubType::Qt3   => "TikQuote".to_string(),            
            SubType::Rb1   => "RightSquareBr".to_string(),       
            SubType::Rb2   => "RightDoubleSqrBr".to_string(),    
            SubType::Rng   => "Range".to_string(),               
            SubType::Rs1   => "RightCurlyBr".to_string(),        
            SubType::Rs2   => "RightDoubleCurlyBr".to_string(),  
            SubType::Sp    => "Space".to_string(),               
            SubType::Stg   => "String".to_string(),              
            SubType::Stl   => "StrLiteral".to_string(),          
            SubType::Txt   => "Text".to_string(),                
        }
    }
}


struct Lexium {
    subtype:  SubType,
    value:    String,
}



impl Lexium {
    fn new(lst: SubType) -> Self {
        Lexium {
            subtype:  lst.clone(),
            value:    Self::new_val(&lst),
        }
    }

    fn new_val(lst: &SubType) -> String {
        match lst {
            SubType::Cm    => ",".to_string(),
            SubType::Dot   => ".".to_string(),
            SubType::Col   => ":".to_string(),
            SubType::Els   => "else".to_string(),
            SubType::End   => "end".to_string(),
            SubType::Eof   => "eof".to_string(),
            SubType::Er    => "".to_string(),
            SubType::Fld   => "".to_string(),
            SubType::Id    => "".to_string(),
            SubType::Iff   => "if".to_string(),
            SubType::Lb1   => "[".to_string(),
            SubType::Lb2   => "[[".to_string(),
            SubType::Ls1   => "{".to_string(),
            SubType::Ls2   => "{{".to_string(),
            SubType::Nl    => "\n".to_string(),
            SubType::Num   => "0".to_string(),
            SubType::Pip   => "|".to_string(),
            SubType::Qt1   => "\"".to_string(),
            SubType::Qt2   => "'".to_string(),
            SubType::Qt3   => "`".to_string(),
            SubType::Rb1   => "]".to_string(),
            SubType::Rb2   => "]]".to_string(),
            SubType::Rng   => "..".to_string(),
            SubType::Rs1   => "}".to_string(),
            SubType::Rs2   => "}}".to_string(),
            SubType::Sp    => " ".to_string(),
            SubType::Stg   => "".to_string(),
            SubType::Stl   => "".to_string(),
            SubType::Txt   => "".to_string(),
        }
    }


    fn t(&self) -> SubType {
        self.subtype.clone()
    }

    fn v(&self) -> String {
        self.value.clone()
    }
}


///Î» Implements Display for Lexium so we can print individual lexia the way we want
impl fmt::Display for Lexium{
    fn fmt(&self, ff: &mut fmt::Formatter) -> fmt::Result {
        write!( ff, "{}", format!("{{{}: {}}}", &self.t().name(), &self.v()) )
    }
}


pub struct Lex {
    cm:   Lexium,
    dot:  Lexium,
    col:  Lexium,
    els:  Lexium,
    end:  Lexium,
    eof:  Lexium,
    er:   Lexium,
    fld:  Lexium,
    id:   Lexium,
    iff:  Lexium,
    lb1:  Lexium,
    lb2:  Lexium,
    ls1:  Lexium,
    ls2:  Lexium,
    nl:   Lexium,
    num:  Lexium,
    pip:  Lexium,
    qt1:  Lexium,
    qt2:  Lexium,
    qt3:  Lexium,
    rb1:  Lexium,
    rb2:  Lexium,
    rng:  Lexium,
    rs1:  Lexium,
    rs2:  Lexium,
    sp:   Lexium,
    stg:  Lexium,
    stl:  Lexium,
    txt:  Lexium,
}


impl Lex {
    pub fn new() -> Self {
        Lex {
            cm:   Lexium::new(SubType::Cm),
            dot:  Lexium::new(SubType::Dot),
            col:  Lexium::new(SubType::Col),
            els:  Lexium::new(SubType::Els),
            end:  Lexium::new(SubType::End),
            eof:  Lexium::new(SubType::Eof),
            er:   Lexium::new(SubType::Er),
            fld:  Lexium::new(SubType::Fld),
            id:   Lexium::new(SubType::Id),
            iff:  Lexium::new(SubType::Iff),
            lb1:  Lexium::new(SubType::Lb1),
            lb2:  Lexium::new(SubType::Lb2),
            ls1:  Lexium::new(SubType::Ls1),
            ls2:  Lexium::new(SubType::Ls2),
            nl:   Lexium::new(SubType::Nl),
            num:  Lexium::new(SubType::Num),
            pip:  Lexium::new(SubType::Pip),
            qt1:  Lexium::new(SubType::Qt1),
            qt2:  Lexium::new(SubType::Qt2),
            qt3:  Lexium::new(SubType::Qt3),
            rb1:  Lexium::new(SubType::Rb1),
            rb2:  Lexium::new(SubType::Rb2),
            rng:  Lexium::new(SubType::Rng),
            rs1:  Lexium::new(SubType::Rs1),
            rs2:  Lexium::new(SubType::Rs2),
            sp:   Lexium::new(SubType::Sp),
            stg:  Lexium::new(SubType::Stg),
            stl:  Lexium::new(SubType::Stl),
            txt:  Lexium::new(SubType::Txt),
        }
    }
}

///Î» Implements Display for Lex so we can print a lex the way we want
impl fmt::Display for Lex{
    fn fmt(&self, ff: &mut fmt::Formatter) -> fmt::Result {
        write!( ff, "[ {} ]", 
            format!("{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}", 
                &self.cm,
                &self.dot,
                &self.col,
                &self.els,
                &self.end,
                &self.eof,
                &self.er,
                &self.fld,
                &self.id,
                &self.iff,
                &self.lb1,
                &self.lb2,
                &self.ls1,
                &self.ls2,
                &self.nl,
                &self.num,
                &self.pip,
                &self.qt1,
                &self.qt2,
                &self.qt3,
                &self.rb1,
                &self.rb2,
                &self.rng,
                &self.rs1,
                &self.rs2,
                &self.sp,
                &self.stg,
                &self.stl,
                &self.txt
            )
        )
    }
}



/// prt_cmd prints the command line that was invoked to run this
pub fn prt_cmd() -> String {

    let args: Vec<String> = env::args().collect();
    let l = Lex::new();

    let mut res = l.ls1.v();
    for arg in args.iter() {
        res = res + &l.lb1.v() + arg + &l.rb1.v() + &l.sp.v();
    }
    // res = res + &l.rs.v();

    print!("\ncommand issued:   {}", res.clone() + &l.nl.v());
    res
}


///Î» check is the module suppervisor (an integration tester) to check functionality in the development vector (dev-vector)
pub fn check() -> Result<(), String> {

    /*
    */
    let my_location = "q1_lex::check";
    print!("\nğŸ¡ğ¡‹ {my_location} \n");
    Ok(())                                                              // don't: panic!("for: No Reason");
}


//Î» The Code Pit
/*
Check scratch_pad, a lot of code framgents moved there
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢

pub fn check() -> Result<(), String> {

    let stg = prt_cmd();
    let my_location = "q1_lex::check";
    print!("{C_LL}ğŸ¡ğ¡‹ {my_location} \n", );

    print!("ğŸ¡ğ¡‹ prt_cmd \n");
    prt_cmd();

    let l = Lex::new();
    print!("l: Lex\n{l}");

    Ok(())
    // don't panic!("for: No Reason");
}
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
Recent Crates

mod s1_lex;                     use s1_lex::{check};
mod sysop_exec;                 use sysop_exec::{check};
mod a84_re_multiline;           use a84_re_multiline::{check};
mod a83_regex_basics;           use a83_regex_basics::{check};
mod a82_string_methods;         use a82_string_methods::{check};

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢

impl Default for Lex {
    fn default() -> Self {
        let lex = Lex::new();
        lex
    }
}

â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
*/
// End Of The Code Pit


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤âœ¨Î»  (Fwdâ€¤ Chrono)
// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// âœ¨Î» mylib::q4_fold  Î¹âœ§21â€¤12â€¤25âœ¦16â€¤50â€¤24â€¤  ğŸŒÎ· âœ§23â€¤01â€¤03â€¤âœ§22â€¤11â€¤16â€¤âœ§22â€¤11â€¤12â€¤âœ§22â€¤08â€¤22â€¤âœ§22â€¤08â€¤19â€¤âœ§22â€¤08â€¤16â€¤âœ§22â€¤08â€¤07â€¤âœ§22â€¤08â€¤05â€¤âœ§22â€¤07â€¤04â€¤

use std::fs;
use std::collections::HashMap;

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
//Î» unit tests -- REALLY HARD TO TEST WITHOUT `use super::*;`

// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
// Traits, Constants, Types Â§ Enums

/// FMap is a Folding Hashmap with 2 metrics
pub type FMap = HashMap<String, (i32, i32)>;


/// allows folding (collapsing) a list of things using methods like: count, sum, mult, etc.
pub trait Fold<FMap> {

    fn new() -> FMap;
    fn init(ss: String) -> FMap;

    fn to_csv(&self, header: &str) -> Result<String, String>;
    fn to_table(&self) -> Result<String, String>;                       // data only, no header 
}


impl Fold<FMap> for FMap {

    fn new() -> FMap {
        let myself: HashMap<String, (i32, i32)> = HashMap::new();
        myself
    }
    
    fn init(ss: String) -> FMap {
        let mut myself = FMap::new();
        for line in ss.lines() {
            match myself.get(line) {
                None => myself.insert(line.to_string(), (0, 1)),
                Some(count) => myself.insert(line.to_string(), (count.0, count.1+1)),
            };
        }
        myself
    }

    fn to_csv(&self, header: &str) -> Result<String, String> { 
        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        let mut res: String = String::new();

        res = res + &header.to_string() + &nl;
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
    fn to_table(&self) -> Result<String, String> { 
        let mut res: String = String::new();

        let cm: String = ",".to_string();
        let nl: String = "\n".to_string();
        for (kk, vv) in self {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
        Ok(res)
    }
}


/// fmap_to_csv converts a hash map to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn fmap_to_csv(fwd: bool, header: &str, fmap: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let hd: String = header.to_string();
    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    if fwd {
        res = res + &hd + &nl;
        for (kk, vv) in fmap {
            res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
        }
    } else {
        res = res + &hd + &nl;
        for (kk, vv) in fmap {
            res = res + &vv.0.to_string() + &cm + &vv.1.to_string() + &cm + &kk + &nl;
        }
    }
    res
}


/// fmap_to_table converts a hash fmap to a csv with headings in forward (k,v) or reverse (v,k) order
pub fn fmap_to_table(fmap: &HashMap<String, (i32, i32)>) -> String {

    let mut res: String = String::new();

    let cm: String = ",".to_string();
    let nl: String = "\n".to_string();
    for (kk, vv) in fmap {
        res = res + &kk + &cm + &vv.0.to_string() + &cm + &vv.1.to_string() + &nl;
    }
    res
}


///Î» fmap_count inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn fmap_count(ss: String) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for line in ss.lines() {
        match res.get(line) {
            None => res.insert(line.to_string(), (0, 1)),
            Some(count) => res.insert(line.to_string(), (count.0, count.1+1)),
        };
    }
    res
}


///Î» fmap_reduce inputs a csv, multiline string, counts the unique lines and returns a hashmap (key: unique_line, value: count_of_duplicates)
pub fn fmap_reduce(hm: HashMap<String, (i32, i32)>) -> HashMap<String, (i32, i32)> {

    let mut res: HashMap<String, (i32, i32)> = HashMap::new();
    for (kk, _) in hm {
        match res.get(&kk) {
            None => res.insert(kk, (0, 1)),
            Some(count) => res.insert(kk, (count.0, count.1+1)),
        };
    }
    res
}


// â€¢â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
///Î» check is an integration tester (int-tester) to check functionality in the development vector (dev-vector)
/// It does the first hashmap iteration of counting duplicates, i.e.:
///  1. reads table from x41_in_data.csv and runs the first hashmapping iteration 
///  2. writes the resulting hashmap to: y41_iter1_res.csv
///  3. removes the last column of the table and writes subtable to: x42_iter1_subtable.csv
pub fn check()  -> Result<String, String> {

    let my_location = "q4_fold::check";
    match fs::read_to_string("/usr/local/sys/sys3rs/data/x41_input_data.csv") {
        Err(ee)       => Err(format!("read_error[{ee}]@{my_location}")),

        Ok(in_string) => {
            let fmap1 = fmap_count(in_string);
            let csv1 = format!("{}\n", fmap_to_csv(true, "col1, col2, cnt1, cnt2", &fmap1));
            
            match fs::write("/usr/local/sys/sys3rs/data/y41_iter1_res.csv", &csv1) {
                Err(ee) => Err(format!("write_fmap_error[{ee}]@{my_location}")),
                _ => {
                    let csv1 = format!("{}\n", fmap_to_table(&fmap1));
                    
                    match fs::write("/usr/local/sys/sys3rs/data/x42_iter1_subtable.csv", &csv1) {
                        Err(ee) => Err(format!("write_key_error[{ee}]@{my_location}")),
                        Ok(()) => Ok(csv1),
                    }
                },
            }
        },
    }
}



â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤âœ¨Î»  (Fwdâ€¤ Chrono)




â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤âœ¨Î»  (Fwdâ€¤ Chrono)




â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤âœ¨Î»  (Fwdâ€¤ Chrono)




â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤7â€¤âœ¨Î»  (Fwdâ€¤ Chrono)


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¤1â€¤ End of
â€¤0â€¤ END OF ARCHIVE OF OLDER COMPLETE MODULES (FWDâ€¤ Chrono)
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·


                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·



                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·


                                                                       ğŸ’¥


                                                               Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·



                                             Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•Â·Â·â•â•â•â•â•â• ğŸ’¥ â•â•â•â•â•â•Â·


Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤4â€¤ğŸ¦¢Î¶Î¹âœ§Â©1991â€¤05â€¤01â€¤TMP: Nomenclature Â§ Glossaryâ€¤


â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢
â€¤3â€¤ğŸ›â„– Header Legend:

áš–â€¤thisâ€¤Fileâ€¤Classification    Î¦â€¤this.Fileâ”€Name     áš–â€¤Cat1â€¤Primary Category           áš–â€¤Subj1â€¤Primary Subjet Areas
Î¿â€¤thisâ€¤Fileâ€¤Ownerâ”€Name                             áš–â€¤Cat2â€¤Secondary Category         áš–â€¤Subj2â€¤Secondary or Specific Subjet Areas

áš–â€¤Fileâ€¤Classification:        â€¢ Î“0â€¤ Pubâ€¤p;  Î“1â€¤ Intâ€¤s;    Î“2â€¤ Confâ€¤s;   Î“3â€¤ Secrâ€¤s;
                              â€¢ Î“4â€¤ TSâ€¤s;   Î“5â€¤ Comp1â€¤s;  Î“6â€¤ Comp2â€¤s;  Î“[789]â€¤ Cryptoâ€¤k;


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢                          Â·                   Â·                   Â·                   Â·            â€¢
â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢                          Â·                   Â·                   Â·                   Â·            â€¢
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·

                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·

                                                                       ğŸ’¥

                                                                 Â·â•â•â•â• ğŸ”» â•â•â•â•Â·

Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• ğŸ”» â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â€¤4â€¤ğŸ¦¢Î¶ TMP: Staging Â§ Footer


â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
â€¢           Â·                   Â·                   Â·                   Â·                   Â·                   Â·                   Â·            â€¢
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
Â·â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•Â·
â”€ â†’ â‡’ â–º ğŸ“ ğŸ”‘ â­ ğŸ’¥ âš¡ ğŸˆ³ ğŸˆ´ â›© ğŸ“ ğŸ¡ â° ğŸ âœ… ğŸƒ ğŸ¦ â­•ï¸ ğŸš« ğŸ‘¥ ğŸ–– ğŸ–– ğŸ‘ ğŸ‘ â®• â¬… â¬† â¬‡          â€¤Janâ€¤Fâ€¤Mâ€¤â€¤Aprâ€¤Mâ€¤Jâ€¤â€¤Julâ€¤Aâ€¤Sâ€¤â€¤Octâ€¤Nâ€¤Dâ€¤
â€¤4â€¤Â©1991â€¤ğ‚â€¤ğ¡‡â€¤ğ’±lpÃ­zğ“™râ€¤(Rafael H. Alpizar Î¹â€¤1991â€¤05â€¤03â€¤) Â§ Â® â— â€¢ Â· ã€ ã€ âˆ âˆ… âœ âœ” âœ˜ â‰™ áš– â‹¯ â‹± â‹° â€¤Aâ€¤â€¤â€¤Bâ€¤Câ€¤â€¤Dâ€¤â€¤â€¤Eâ€¤Fâ€¤â€¤Gâ€¤â€¤â€¤Hâ€¤Iâ€¤â€¤Jâ€¤â€¤â€¤Kâ€¤Lâ€¤
â€¢â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•Â·Â·â•â•â•â•â•â•â•â•â•â•â•â€¢

